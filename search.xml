<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>afl</title>
      <link href="/2022/09/03/sample/"/>
      <url>/2022/09/03/sample/</url>
      
        <content type="html"><![CDATA[<h4 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h4><h5 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> afl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFLplusplus</title>
      <link href="/2022/09/03/fuzz/AFLplusplus/"/>
      <url>/2022/09/03/fuzz/AFLplusplus/</url>
      
        <content type="html"><![CDATA[<h4 id="0x00-インストール"><a href="#0x00-インストール" class="headerlink" title="0x00 インストール"></a>0x00 インストール</h4><h5 id="インストールに必要なものt"><a href="#インストールに必要なものt" class="headerlink" title="インストールに必要なものt"></a>インストールに必要なものt</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git build-essential curl libssl-dev sudo libtool libtool-bin libglib2.0-dev bison flex automake python3 python3-dev python3-setuptools libpixman-1-dev gcc-10-plugin-dev cgroup-tools \</span><br><span class="line">clang-11 clang-tools-11 libc++1-11 libc++-11-dev libc++abi1-11 libc++abi-11-dev libclang1-11 libclang-11-dev libclang-common-11-dev libclang-cpp11 libclang-cpp11-dev liblld-11 liblld-11-dev liblldb-11 liblldb-11-dev libllvm11 libomp-11-dev libomp5-11 lld-11 lldb-11 python3-lldb-11 llvm-11 llvm-11-dev llvm-11-runtime llvm-11-tools libstdc++-10-dev</span><br></pre></td></tr></table></figure><h5 id="llvmのウェブサイトの指示に従って、llvmの依存関係をインストールします。"><a href="#llvmのウェブサイトの指示に従って、llvmの依存関係をインストールします。" class="headerlink" title="llvmのウェブサイトの指示に従って、llvmの依存関係をインストールします。"></a>llvmのウェブサイトの指示に従って、llvmの依存関係をインストールします。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -c &quot;$(wget -O - https://apt.llvm.org/llvm.sh)&quot;</span><br></pre></td></tr></table></figure><h5 id="そして、clangなどのコンパイラを切り替えて使用します。"><a href="#そして、clangなどのコンパイラを切り替えて使用します。" class="headerlink" title="そして、clangなどのコンパイラを切り替えて使用します。"></a>そして、clangなどのコンパイラを切り替えて使用します。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/clang clang `which clang-11` 1</span><br><span class="line">sudo update-alternatives --install /usr/bin/clang++ clang++ `which clang++-11` 1</span><br><span class="line">sudo update-alternatives --install /usr/bin/llvm-config llvm-config `which llvm-config-11` 1</span><br><span class="line">sudo update-alternatives --install /usr/bin/llvm-symbolizer llvm-symbolizer `which llvm-symbolizer-11` 1</span><br></pre></td></tr></table></figure><h5 id="依存関係が全て揃った状態で、afl-をダウンロードし、コンパイルしてください。"><a href="#依存関係が全て揃った状態で、afl-をダウンロードし、コンパイルしてください。" class="headerlink" title="依存関係が全て揃った状態で、afl++をダウンロードし、コンパイルしてください。"></a>依存関係が全て揃った状態で、afl++をダウンロードし、コンパイルしてください。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/AFLplusplus/AFLplusplus</span><br><span class="line">$ cd AFLplusplus</span><br><span class="line">$ git checkout 2.68c # if you want a specific version, otherwise skip this step</span><br><span class="line">$ make distrib</span><br><span class="line">$ sudo make install</span><br><span class="line">$ sudo /path/AFLplusplus/afl-system-config</span><br></pre></td></tr></table></figure><h3 id="0x01-harness"><a href="#0x01-harness" class="headerlink" title="0x01 harness"></a>0x01 harness</h3><p>ハーネスの役割は、特定のライブラリコードに対するテストフレームワークの書き方を、デモを通して体験していただくことです。</p><p>研究テスターは、入力コーパスを作成し、変異させたコーパスを提供する。テストコード用のフレームワーク（書き込みハーネス）を書き、afl-clang-fast&#x2F;afl-gcc スタブでコンパイルし、フィードバックファズテストをサポートするバイナリを生成する。afl-fuzzは、キューを選び出し 変異したサンプルはテストフレームワーク（ハーネス）に投げられ、結果を監視します。もしクラッシュした場合はクラッシュに格納され、もし新しいパスのトリガーに成功した場合はキューに追加されます。</p><p>この実験は、ライブラリ文庫に対してテストコードを書くことで、ハーネスの書き方を理解するものでした。</p><p>ライブラリライブラリには、以下のようにlibrary.hで定義され、library.cで実装された2つのライブラリ関数があります。 目標は、この2つのライブラリ関数をaflを介してファジングできるアプリケーションフレームワークを書くことである。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">// an &#x27;nprintf&#x27; implementation - print the first len bytes of data</span><br><span class="line">void lib_echo(char *data, ssize_t len);</span><br><span class="line"></span><br><span class="line">// optimised multiply - returns x*y</span><br><span class="line">int  lib_mul(int x, int y);</span><br></pre></td></tr></table></figure><p>の機能は、次のとおりです。</p><ul><li>lib_echo：パラメータデータに含まれる文字列の最初のlenを出力する。</li><li>lib_mul：パラメータ x に y を乗じた値を出力する。</li></ul><p>私たちの目標は、この2つの機能に対するファジーテストを実装するためのフレームワークを書くことである。</p><p>この目的を達成するために、フレームワークには次のような機能が必要です。</p><ul><li>コンパイルされたプログラムは実行可能でなければならない。すなわち、実行可能なバイナリプログラムにコンパイルできるように、main関数が必要である。</li><li>aflをより効率的にファズするための情報をフィードバックする機能。つまり、書かれたコードをスタブ化し、afl-clang-fastやafl-clang、afl-gccを使ってコンパイルする必要があるのです。</li><li>afl が変異するためのデータインタフェースを提供する。すなわち、2つの関数が使用するパラメータデータは標準入力またはファイルから来るようにし、afl が変異しやすいようにすることである。</li></ul><p>最終的に書かれたコードは以下の通りです。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;library.h&quot;</span><br><span class="line"></span><br><span class="line">// fixed size buffer based on assumptions about the maximum size that is likely necessary to exercise all aspects of the target function</span><br><span class="line">#define SIZE 100</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">    if((argc == 2) &amp;&amp; strcmp(argv[1], &quot;echo&quot;) == 0) &#123;</span><br><span class="line">        // make sure buffer is initialized to eliminate variable behaviour that isn&#x27;t dependent on the input.</span><br><span class="line">        char input[SIZE] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">        ssize_t length;</span><br><span class="line">        length = read(STDIN_FILENO, input, SIZE);</span><br><span class="line"></span><br><span class="line">        lib_echo(input, length);</span><br><span class="line">    &#125; else if ((argc == 2) &amp;&amp; strcmp(argv[1], &quot;mul&quot;) == 0) &#123;</span><br><span class="line">        int a,b = 0;</span><br><span class="line">        read(STDIN_FILENO, &amp;a, 4);</span><br><span class="line">        read(STDIN_FILENO, &amp;b, 4);</span><br><span class="line">        printf(&quot;%d\n&quot;, lib_mul(a,b));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;Usage: %s mul|echo\n&quot;, argv[0]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main 関数は、lib_echo 関数と lib_mul のどちらをファズテストするか決めるためにコマンドライン引数を取り（最初の要件を満たす）、次に標準入力の読み込みデータを引数として関数を呼び出し（2番目の要件を満たす）、最後にプログラムが afl-clang-fast でコンパイルされてフレーム生成 ( 第2要件を満たしている）。</p><p>コンパイルコマンドは</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AFL_HARDEN=1 afl-clang-fast harness.c library.c -o harness</span><br></pre></td></tr></table></figure><p>次に、lib_echo ライブラリ関数のファジングテストを実施します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir echo_in</span><br><span class="line">echo aaaaaa &gt; echo_in/seed</span><br><span class="line">afl-fuzz -i echo_in -o out ./harness echo</span><br></pre></td></tr></table></figure><p>シードファイルを格納する echo_in フォルダを作成し、aaaaaa をシードファイルとして作成し、afl-fuzz を起動して lib_echo をファジングテストします。</p><p>というクラッシュをファジー化するのに時間はかかりません。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat out/default/crashes/id:000000,sig:06,src:000004,time:63255,op:havoc,rep:4</span><br><span class="line">pop!)!!!!%![1m</span><br></pre></td></tr></table></figure><p>lib_mul 関数のファジーテスト。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir mul_in</span><br><span class="line">echo &quot;1   3   &quot; &gt; mul_in/seed</span><br><span class="line">afl-fuzz -i mul_in -o out ./harness mul</span><br></pre></td></tr></table></figure><p>シードファイルを格納する echo_mul フォルダを作成し、1 3 の内容をシードファイルとして作成し、afl-fuzz を起動して lib_mul をファズテストします。</p><p>もちろん、コマンドラインでmulとechoのどちらかを指定するのではなく、特定の関数をファジングし、両方を同時にテストすることを考えることも可能である。</p><p>このデモでは、特定のターゲットをファジングする際に、aflをベースにした最適化フレームワークを書いて、コードをファジングする方法を紹介します。</p><h4 id="0x01-challenges"><a href="#0x01-challenges" class="headerlink" title="0x01 challenges"></a>0x01 challenges</h4><p>課題は、脆弱性を持つ実際のターゲットを、aflを使ってファズテストし、対応する脆弱性の発見に成功することで、aflの使い方をさらにマスターし、オリジナルの</p><h5 id="libxml2"><a href="#libxml2" class="headerlink" title="libxml2"></a>libxml2</h5><p>RUNOOB XMLチュートリアルによると、xmlとはeXtensible Markup Languageのことで、データの転送や保存を行うために設計された言語です。</p><p>XML文書は、「ルート」から始まって「ブランチ」へと展開するツリー構造を形成している。 この要素は、他のすべての要素の親となる。</p><p>XML文書内の要素は文書ツリーを形成する。 根元から始まり、木の下まで広がっていく。</p><p>すべての要素は子要素を持つことができる。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;root&gt;</span><br><span class="line">&lt;child&gt;</span><br><span class="line">&lt;subchild&gt;.....&lt;/subchild&gt;</span><br><span class="line">&lt;/child&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure><p>要素間の関係を表す用語として、親、子、兄弟がある。 親要素は子要素を所有する。 同じレベルの子要素は兄弟（姉妹）になる。</p><p>libxml2 ライブラリは，XML 文書をパースするための関数を集めたライブラリです． C言語で書かれており、複数の言語で呼び出すことができます。 私たちの目標は、libxml2 ライブラリを afl++ でファズテストし、xml ファイル形式のパースにおける脆弱性を突くことができるかどうか確認することです。</p><p>そのために、まず、afl-trainingに従って、対応するバージョンのlibxml2をダウンロードします。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/GNOME/libxml2.git</span><br><span class="line">cd libxml2</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br><span class="line">git checkout v2.9.2</span><br></pre></td></tr></table></figure><p>その後、コンパイルしてください。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC=afl-clang-fast ./autogen.sh </span><br><span class="line">AFL_USE_ASAN=1 make -j 4</span><br></pre></td></tr></table></figure><p>環境変数の役割は、公式マニュアル - env_variables.txt で確認できます。 AFL_USE_ASAN の役割は、ASAN 機能を有効にしてクラッシュをよりよく検出できるようにすることです。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- Setting AFL_USE_ASAN automatically enables ASAN, provided that your</span><br><span class="line">  compiler supports that. Note that fuzzing with ASAN is mildly challenging</span><br><span class="line">  - see notes_for_asan.txt.</span><br></pre></td></tr></table></figure><p>libxml2は様々なインタフェースを提供しており、公式マニュアルを読めばさらに理解が深まるでしょう。</p><p>我々の目的は、ソフトウェアの脆弱性を掘り下げることではなく、ソフトウェアの脆弱性を掘り下げることでaflの使い方をさらにマスターすることなので、Libxml2の公式サンプル集を見て、parse1.c: XMLファイルを木にパースして、それを自由に修正していくことを選べばいいのです。 その結果、以下のようなharness.cのコードが出来上がりました。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;libxml/parser.h&quot;</span><br><span class="line">#include &quot;libxml/tree.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    if (argc != 2)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    xmlDocPtr doc; /* the resulting document tree */</span><br><span class="line"></span><br><span class="line">    doc = xmlReadFile(argv[1], NULL, 0);</span><br><span class="line">    if (doc == NULL) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    xmlFreeDoc(doc);</span><br><span class="line"></span><br><span class="line">    xmlCleanupParser();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主なファズAPIは、xmlReadFile、xmlFreeDoc、xmlCleanupParser関数で、コマンドラインからxmlファイル名が渡され、それに続いてファイルデータをパースする対応する関数が渡されることがわかると思います。 afl関数は、libxml2をファズテストするために、xmlファイルを変異させるために使用されます。</p><p>ハーネスをコンパイルするためのコマンドは以下のとおりです。 -I はヘッダファイルのあるパスを指定し，ファジング対象の関数をハーネスにリンクするために libxml2 の静的リンクライブラリを，-lm は数学ライブラリを，-lz は zlib ライブラリを使用することを指定します．</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AFL_USE_ASAN=1 afl-clang-fast ./harness.c -I ~/work/fuzz/libxml2/include ~/work/fuzz/libxml2/.libs/libxml2.a -lz -lm -o fuzzer</span><br></pre></td></tr></table></figure><p>ファジーテストのシードファイルを作成します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir in</span><br><span class="line">vim in/seed.xml</span><br></pre></td></tr></table></figure><p>seed.xml文件内容如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">  &lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">  &lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">  &lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">  &lt;body&gt;Don&#x27;t forget me this weekend!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure><p>ファザーを起動します。<br>afl-fuzz -i in -o out .&#x2F;fuzzer @@<br>この場合、メモリの制限によりエラーとなる場合があります。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-] Whoops, the target binary crashed suddenly, before receiving any input</span><br><span class="line">    from the fuzzer! Since it seems to be built with ASAN and you have a</span><br><span class="line">    restrictive memory limit configured, this is expected; please read</span><br><span class="line">    /usr/local/share/doc/afl/notes_for_asan.md for help.</span><br><span class="line"></span><br><span class="line">[-] PROGRAM ABORT : Fork server crashed with signal 6</span><br><span class="line">         Location : afl_fsrv_start(), src/afl-forkserver.c:76</span><br></pre></td></tr></table></figure><p>解決策としては、-m noneを追加して、メモリ制限を解除する。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -m none -i in -o out ./fuzzer @@</span><br></pre></td></tr></table></figure><p>不一会就会跑出crash，重现分析崩溃现场如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">==21614==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x621000002500 at pc 0x00000057da50 bp 0x7fffffffe070 sp 0x7fffffffe068</span><br><span class="line">READ of size 1 at 0x621000002500 thread T0</span><br><span class="line">    #0 0x57da4f in xmlParseXMLDecl /home/f0cus7/fuzz/libxml2/parser.c:10666:2</span><br><span class="line">    #1 0x57eed9 in xmlParseDocument /home/f0cus7/fuzz/libxml2/parser.c:10771:2</span><br><span class="line">    #2 0x5bfbbf in xmlDoRead /home/f0cus7/fuzz/libxml2/parser.c:15298:5</span><br><span class="line">    #3 0x5bfbbf in xmlReadFile /home/f0cus7/fuzz/libxml2/parser.c:15360:13</span><br><span class="line">    #4 0x4c6080 in main /home/f0cus7/fuzz/afl-training/challenges/libxml2/./harness.c:20:11</span><br><span class="line">    #5 0x7ffff6c07b96 in __libc_start_main /build/glibc-2ORdQG/glibc-2.27/csu/../csu/libc-start.c:310</span><br><span class="line">    #6 0x41c369 in _start (/home/f0cus7/fuzz/afl-training/challenges/libxml2/fuzzer+0x41c369)</span><br><span class="line"></span><br><span class="line">0x621000002500 is located 0 bytes to the right of 4096-byte region [0x621000001500,0x621000002500)</span><br><span class="line">allocated by thread T0 here:</span><br></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    // parser.c:10666</span><br><span class="line">    MOVETO_ENDTAG(CUR_PTR);</span><br><span class="line">    NEXT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// include/libxml/parseInternals.h: 297</span><br><span class="line">#define MOVETO_ENDTAG(p)                        \</span><br><span class="line">    while ((*p) &amp;&amp; (*(p) != &#x27;&gt;&#x27;)) (p)++</span><br></pre></td></tr></table></figure><p>可以看到应该是由于*p访问字符串末尾越界导致的，实质上它不算是漏洞，而是正常的行为。</p><p>将它进行patch，将该函数添加到asan的白名单之中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void __attribute__((no_sanitize_address)) MOVETO_ENDTAG_PATCH(xmlChar *p)</span><br><span class="line">&#123;</span><br><span class="line">    while ((*p) &amp;&amp; (*(p) != &#x27;&gt;&#x27;)) (p)++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ハーネスと同様にlibxml2をコンパイルして再度実行すると、簡単にクラッシュすることはない。</p><p>ご感想<br>パッチを当てた後、クラッシュを実行するのは難しいので、主に以下の方法でファズテストを効率的に実行できるかを考えてください。</p><ul><li>より効率的なxmlサンプルの提供、サンプルのさらなる改良。</li><li>より多くの libxml2 インターフェースのファズテストを行い、さらに複雑なハーネスを作成した。</li><li>harness.cをより効率的にするための改良を行いました。</li></ul><p>1つ目は、fuzzdataのxmlデータなど、インターネット上でより有効なxmlファイルを探し、afl-cminやafl-tminツールを使ってサンプルを絞り込むことで、実現できる。</p><p>もうひとつは、公式マニュアルを読んで、ハーネスがより多くのデータ・インターフェースをカバーし、より複雑な操作を行えるようにすることでした。</p><p>3つ目は、AFL-FUZZに従ってllvmを有効にしてharness.cを改善することです。 llvmを有効にしてafl-clang-fastでharnessをコンパイルすると、__AFL_LOOPをコードに追加してAFL persistent modeを使ってフロックを削減し、さらなる効率化を図ります。</p><p>下記のように、__AFL_LOOPを追加することで、aflは一旦処理を開始し、その後に指定された数（1000）に応じて1000個のサンプルを生成し、次の処理を再開するまでに1000回実行し、フォークの回数を減らして効率を向上させます。 また、ファジーテストにaflを使用する代わりに、プログラム単体で実行するとループが動作しないため、解析クラッシュサイトを再現する場合でも、同じプログラムを使用することができるという効果を得ることができます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (__AFL_LOOP(1000))</span><br><span class="line">   &#123;</span><br><span class="line">       XXXXXX</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>そこで、上記のハーネスを以下のように修正し、コンパイルして再度ファズテストを行ったところ、効率が大幅に向上したことが確認できます（1000回&#x2F;秒から6000回&#x2F;秒に）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;libxml/parser.h&quot;</span><br><span class="line">#include &quot;libxml/tree.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    if (argc != 2)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    xmlDocPtr doc; /* the resulting document tree */</span><br><span class="line"></span><br><span class="line">    while (__AFL_LOOP(1000)) &#123;</span><br><span class="line"></span><br><span class="line">        doc = xmlReadFile(argv[1], NULL, 0);</span><br><span class="line">        if (doc != NULL) &#123;</span><br><span class="line">            xmlFreeDoc(doc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xmlCleanupParser();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="heartbleed"><a href="#heartbleed" class="headerlink" title="heartbleed"></a>heartbleed</h5><p>heartbleedの脆弱性は古典的なものですが、もちろんこの脆弱性解析がこの記事の主目的ではなく、この実験の目的は、aflを使って脆弱性のクラッシュポイントを掘り起こす方法です。</p><p>heartbleedの脆弱性は古典的なものですが、もちろんこの脆弱性解析がこの記事の主目的ではなく、この実験の目的は、aflを使って脆弱性のクラッシュポイントを掘り起こす方法です。</p><p>Heartbleed 脆弱性は CVE-2014-0160 で、OpenSSL バージョン 1.0.1 の深刻な脆弱性です。 この脆弱性はメモリオーバーランを引き起こし、攻撃者はリモートから OpenSSL サーバメモリに格納された 64K のデータを読み取ることができます。 影響を受けるバージョン： OpenSSL バージョン 1.0.1, 1.0.1a, 1.0.1b, 1.0.1c, 1.0.1d, 1.0.1e, 1.0.1f, OpenSSL 1.0.2 の Beta 1, など。</p><p>tlsデータ転送処理を以下に示します。opensslはtls&#x2F;ssl転送プロトコルをサポートするほど友好的です。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Client                                             Server</span><br><span class="line">------                                             ------</span><br><span class="line"></span><br><span class="line">                           (1)</span><br><span class="line">ClientHello             --------&gt;                                 |</span><br><span class="line">                                              ServerHello         |</span><br><span class="line">                                             Certificate*         |</span><br><span class="line">                                       ServerKeyExchange*         |</span><br><span class="line">                                      CertificateRequest*         |</span><br><span class="line">                           (2)                                    |</span><br><span class="line">                        &lt;--------         ServerHelloDone         |</span><br><span class="line">Certificate*                                                      |</span><br><span class="line">ClientKeyExchange                                                 |--- HANDSHAKE</span><br><span class="line">CertificateVerify*                                                |</span><br><span class="line">[ChangeCipherSpec]                                                |</span><br><span class="line">                           (3)                                    |</span><br><span class="line">Finished                --------&gt;                                 |</span><br><span class="line">                                       [ChangeCipherSpec]         |</span><br><span class="line">                           (4)                                    |</span><br><span class="line">                        &lt;--------                Finished         |</span><br><span class="line"></span><br><span class="line">Application Data        &lt;-------&gt;        Application Data</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>BIOは、opensslが実装するtls&#x2F;sslプロトコルフローにおいてより重要な概念の1つであり、データをさらにカプセル化したものです。 具体的に参照できる記事は以下の通りです。</p><ul><li>Using OpenSSL with memory BIOs</li><li>OpenSSL BIO_s_mem example</li><li>Directly Read&#x2F;Write Handshake data with Memory BIO</li></ul><p>ここでは、ファジーテストに関連する部分の始め方について説明します。</p><p>まず、マニュアルに従ってopenssl 1.0.1fをコンパイルします。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/openssl/openssl.git</span><br><span class="line">git checkout OpenSSL_1_0_1f</span><br><span class="line">CC=afl-clang-fast CXX=afl-clang-fast++ ./config -d</span><br><span class="line">AFL_USE_ASAN=1 make</span><br></pre></td></tr></table></figure><p>コンパイルしたら、次はハーネスを書いて、handshake.ccのキーコードを見ます。 Memory BIOサーバーを開き、BIO_write関数を呼び出してBIOキューにデータを書き込んでいるのがわかりますが、データは未定義です。 ハーネスを完成させるためには、主にデータを定義することが必要です。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">  static SSL_CTX *sctx = Init();</span><br><span class="line">  SSL *server = SSL_new(sctx);</span><br><span class="line">  BIO *sinbio = BIO_new(BIO_s_mem());</span><br><span class="line">  BIO *soutbio = BIO_new(BIO_s_mem());</span><br><span class="line">  SSL_set_bio(server, sinbio, soutbio);</span><br><span class="line">  SSL_set_accept_state(server);</span><br><span class="line"></span><br><span class="line">  /* TODO: To spoof one end of the handshake, we need to write data to sinbio</span><br><span class="line">   * here */</span><br><span class="line">  BIO_write(sinbio, data, size);</span><br><span class="line"></span><br><span class="line">  SSL_do_handshake(server);</span><br><span class="line">  SSL_free(server);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>データをバッファとして定義し、そのデータを標準入力から取得して、aflにバリアントデータを提供することができます、最終的なメイン関数は以下のようになります。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">  static SSL_CTX *sctx = Init();</span><br><span class="line">  SSL *server = SSL_new(sctx);</span><br><span class="line">  BIO *sinbio = BIO_new(BIO_s_mem());</span><br><span class="line">  BIO *soutbio = BIO_new(BIO_s_mem());</span><br><span class="line">  SSL_set_bio(server, sinbio, soutbio);</span><br><span class="line">  SSL_set_accept_state(server);</span><br><span class="line"></span><br><span class="line">  /* TODO: To spoof one end of the handshake, we need to write data to sinbio</span><br><span class="line">   * here */</span><br><span class="line">  char data [0x100];</span><br><span class="line">  size_t size = read(STDIN_FILENO, data, 0x100);</span><br><span class="line">  if(size == -1) &#123;</span><br><span class="line">      return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  BIO_write(sinbio, data, size);</span><br><span class="line"></span><br><span class="line">  SSL_do_handshake(server);</span><br><span class="line">  SSL_free(server);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ハーネスをコンパイルするためのコマンドは以下のとおりです。 -ldl は、ライブラリに接続するようにコネクタに指示します。 このライブラリには、dlopenやdlsymなどの関数、すなわちダイナミックリンクによるライブラリの実行時読み込みをサポートするライブラリが含まれています。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AFL_USE_ASAN=1 afl-clang-fast++ -g handshake.cc ~/Desktop/openssl/libcrypto.a ~/Desktop/openssl/libssl.a ~/Desktop/openssl/libcrypto.a ~/Desktop/openssl/libssl.a -o handshake -I ~/Desktop/openssl/include -ldl</span><br></pre></td></tr></table></figure><p>変異のインプットとなるシードファイルを作成します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir in</span><br><span class="line">echo 11111 &gt; in/seed</span><br></pre></td></tr></table></figure><p>ファイナルファズ</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -m none -i in -o out ./handshake</span><br></pre></td></tr></table></figure><p>しばらく走って、無事クラッシュがなくなった後。</p><p>AFL_USE_ASAN&#x3D;1 afl-clang-fast++ -g handshake.cc &#x2F;home&#x2F;lzt&#x2F;openssl&#x2F;libcrypto.a &#x2F;home&#x2F;lzt&#x2F;openssl&#x2F;libssl.a  -o handshake -I ~&#x2F;Desktop&#x2F;openssl&#x2F;include -ldl</p><p>ANSWERS.mdとHINTS.mdを見ると、ASANが有効になっているので、docs&#x2F;notes_for_asan.txtを読むと良いと書いてあります。 ドキュメントを読んでみると、ファズのためにASANを有効にすると、メモリを600-800m程度消費するので32ビットプログラムを実行すると良いことがわかりますが、一方で 64bitの場合、消費するメモリは17.5TB～20TB程度となるため、64bitのプログラムを直接実行するとエラーが発生する可能性があります。</p><p>どうしても実行したい場合は、root 権限で asan_cgroups&#x2F;limit_memory.sh スクリプトを呼び出します (sudo ~&#x2F;AFLplusplus&#x2F;examples&#x2F;asan_cgroups&#x2F;limit_memory.sh -u fuzzer afl-fuzz -i in) 。-o out -m none . &#x2F;handshake); 上記のように -m none を渡して実行することもできますが、この場合、プログラムがメモリを過剰に消費してしまい、システムによって強制終了される可能性があります。</p>]]></content>
      
      
      <categories>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AFLplusplus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2022-32250</title>
      <link href="/2022/09/03/bin/linux/cve-2022-32250/"/>
      <url>/2022/09/03/bin/linux/cve-2022-32250/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> cve </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cve-2022-2586</title>
      <link href="/2022/09/01/bin/linux/cve-2022-2586/"/>
      <url>/2022/09/01/bin/linux/cve-2022-2586/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> cve </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>afl</title>
      <link href="/2022/09/01/fuzz/afl/"/>
      <url>/2022/09/01/fuzz/afl/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> afl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>misc</title>
      <link href="/2022/09/01/ctf/misc/misc/"/>
      <url>/2022/09/01/ctf/misc/misc/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linuxカーネル デーバグ</title>
      <link href="/2022/08/31/bin/cve/"/>
      <url>/2022/08/31/bin/cve/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> cve </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve-2022-2586 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE 脆弱性解析</title>
      <link href="/2017/05/26/debug/linux/linux_debug/"/>
      <url>/2017/05/26/debug/linux/linux_debug/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> cve </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ida</title>
      <link href="/2017/03/26/debug/ida/ida/"/>
      <url>/2017/03/26/debug/ida/ida/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> ida </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ida </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linuxカーネルデバッグメソッドまとめ</title>
      <link href="/2017/03/26/debug/linux/linux_kernel_debug/"/>
      <url>/2017/03/26/debug/linux/linux_kernel_debug/</url>
      
        <content type="html"><![CDATA[<p>カーネル開発がユーザー空間の開発より難しい要因の1つは、カーネルのデバッグの難しさである。 カーネルエラーはシステムダウンにつながることが多く、何が問題だったのか現場を保存することが難しい。 カーネルのデバッグで重要なのは、カーネルを深く理解することです。</p><h4 id="I-コミッショニング準備"><a href="#I-コミッショニング準備" class="headerlink" title="I コミッショニング準備"></a>I コミッショニング準備</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- バグが確認されています。</span><br><span class="line">- バグを含むカーネルのバージョン番号を解析して、どのバージョンでバグが発生したかを調べる必要があり、問題解決に非常に役立つ。 二項対立の検索で、バグが発生したバージョン番号を徐々に特定することができる。</span><br><span class="line">- カーネルコードの理解が深ければ深いほどよく、ちょっとした運も必要です。</span><br><span class="line">- このバグは再現可能です。 再発パターンが見つかれば、原因究明はそう遠くないはずです。</span><br><span class="line">- システムを最小化する。 バグを発生させる要因をひとつひとつ排除していく。</span><br></pre></td></tr></table></figure><h4 id="II-カーネルに発生するバグ"><a href="#II-カーネルに発生するバグ" class="headerlink" title="II カーネルに発生するバグ"></a>II カーネルに発生するバグ</h4><p>カーネルのバグも多様です。 その理由はさまざまで、見た目もさまざまです。 ソースコードに隠されたバグから、目に見える形で明らかになったバグまで、その発症は多くの場合、連鎖的に引き起こされる。 カーネルデバッグは難しいですが、努力と理解次第で楽しくチャレンジできるかもしれません。</p><h4 id="III-カーネルデバッグコンフィギュレーションオプション"><a href="#III-カーネルデバッグコンフィギュレーションオプション" class="headerlink" title="III カーネルデバッグコンフィギュレーションオプション"></a>III カーネルデバッグコンフィギュレーションオプション</h4><h5 id="1-カーネル構成"><a href="#1-カーネル構成" class="headerlink" title="1 カーネル構成"></a>1 カーネル構成</h5><p>カーネルデバッグを可能にするために、カーネルコンフィギュレーションにいくつかの項目が追加されました。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> Kernel hacking  ---&gt;      </span><br><span class="line"></span><br><span class="line">[*]   Magic SysRq key </span><br><span class="line"></span><br><span class="line">[*]   Kernel debugging </span><br><span class="line"></span><br><span class="line">[*]   Debug slab memory allocations   </span><br><span class="line"></span><br><span class="line">[*]   Spinlock and rw-lock debugging: basic checks </span><br><span class="line"></span><br><span class="line">[*]   Spinlock debugging: sleep-inside-spinlock checking </span><br><span class="line"></span><br><span class="line">           [*]   Compile the kernel with debug info   </span><br><span class="line"></span><br><span class="line">Device Drivers  ---&gt;   </span><br><span class="line"></span><br><span class="line">           Generic Driver Options  ---&gt; </span><br><span class="line"></span><br><span class="line">           [*]   Driver Core verbose debug messages </span><br><span class="line"></span><br><span class="line">General setup  ---&gt; </span><br><span class="line"></span><br><span class="line">           [*]   Configure standard kernel features (<span class="keyword">for</span> small systems)  ---&gt; </span><br><span class="line"></span><br><span class="line">           [*]   Load all symbols <span class="keyword">for</span> debugging/ksymoops</span><br></pre></td></tr></table></figure><p>オプションを有効にする 例 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">slab layer debuggingスラブレイヤーデバッグオプション </span><br><span class="line"></span><br><span class="line">high-memory debuggingハイメモリーデバッギングオプション </span><br><span class="line"></span><br><span class="line">I/O mapping debuggingI/Oマッピングのデバッグオプション </span><br><span class="line"></span><br><span class="line">spin-lock debuggingスピンロック・デバッグ・オプション </span><br><span class="line"></span><br><span class="line">stack-overflow スタックオーバーフローチェックオプション </span><br><span class="line"></span><br><span class="line">sleep-inside-spinlock checkingスリープインサイドスピンロックチェック</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-アトミック操作のデバッグ"><a href="#2-アトミック操作のデバッグ" class="headerlink" title="2 アトミック操作のデバッグ"></a>2 アトミック操作のデバッグ</h5><p>カーネル2.5から開発されたカーネルは、アトミック操作に起因するあらゆる種類の問題をチェックするための優れたツールを提供しています。<br>カーネルはアトミックオペレーションカウンターを提供しており、アトミックオペレーション中に着信都市がスリープしたり、スリープを引き起こすようなことをするとすぐに警告メッセージを表示し、トレースの手がかりを提供するよう設定することができる。<br>そのため、ロック中にschedule()を呼び出す、ロック中にブロッキングでメモリ割り当てを要求するなど、あらゆる潜在的なバグを検出することができる。<br>以下のオプションは、この機能を最大限に活用するものです。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_PREEMPT = y </span><br><span class="line"></span><br><span class="line">CONFIG_DEBUG_KERNEL = y </span><br><span class="line"></span><br><span class="line">CONFIG_KLLSYMS = y </span><br><span class="line"></span><br><span class="line">CONFIG_SPINLOCK_SLEEP = y</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="IV-バグを発生させる、メッセージを表示する"><a href="#IV-バグを発生させる、メッセージを表示する" class="headerlink" title="IV バグを発生させる、メッセージを表示する"></a>IV バグを発生させる、メッセージを表示する</h4><h5 id="1-BUG-およびBUG-ON"><a href="#1-BUG-およびBUG-ON" class="headerlink" title="1 BUG()およびBUG_ON()"></a>1 BUG()およびBUG_ON()</h5><p>多くのカーネルコールを使って、簡単にバグのフラグを立てたり、アサーションを提供したり、情報を出力したりすることができます。 よく使われるのはBUG()とBUG_ON()の2つです。</p><p>&lt;include&#x2F;asm-generic&gt; で定義されています。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ifndef HAVE_ARCH_BUG </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define BUG() do &#123; </span></span><br><span class="line"></span><br><span class="line">   printk(<span class="string">&quot;BUG: failure at %s:%d/%s()! &quot;</span>, __FILE__, __LINE__, __FUNCTION__); </span><br><span class="line"></span><br><span class="line">   panic(<span class="string">&quot;BUG!&quot;</span>);   /* より深刻なエラーが発生し、エラーメッセージが表示されるだけでなく、システム全体がハングアップしてしまう */ </span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (0) </span><br><span class="line"></span><br><span class="line"><span class="comment">#endif </span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">#ifndef HAVE_ARCH_BUG_ON </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">#define BUG_ON(condition) do &#123; if (unlikely(condition)) BUG(); &#125; while(0) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>この2つのマクロが呼び出されると、OOPSが発生し、スタックトレースバックとエラーメッセージが出力されます。<br>※ BUG_ON(bad_thing) のように、この2つの呼び出しをアサーションとして使用することが可能です。</p><h5 id="2-dump-stack"><a href="#2-dump-stack" class="headerlink" title="2  dump_stack()"></a>2  dump_stack()</h5><p>デバッグのために、スタック・トレースバックをターミナルに出力するだけでよい場合もあります。 そこで、dump_stack()を使用することができます。 この関数は、レジスタコンテキストと関数のトレースバックトレイルのみをターミナルに表示します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!debug_check) &#123; </span><br><span class="line"></span><br><span class="line">    printk(KERN_DEBUG “provide some information…/n”); </span><br><span class="line"></span><br><span class="line">    dump_stack(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="v-printk"><a href="#v-printk" class="headerlink" title="v printk()"></a>v printk()</h4><p>カーネルが提供する書式印刷機能。</p><h5 id="1-printk関数のロバスト性"><a href="#1-printk関数のロバスト性" class="headerlink" title="1 printk関数のロバスト性"></a>1 printk関数のロバスト性</h5><p>堅牢性はprintkの最も受け入れられる品質の1つであり、カーネルはほとんどどこでも、いつでも（割り込みコンテキスト、プロセスコンテキスト、ロック保持時、マルチプロセッシング時など）呼び出すことができます。</p><p>#####2 printk関数の脆弱性<br> システムのブートプロセスでは、ターミナルが初期化されるまで呼び出すことができない場所があります。 どうしてもシステム起動時の一番最初のデバッグが必要な場合は、以下の方法があります。</p><p>他の端末機器にデバッグ情報を出力する、シリアルデバッグを使用する。</p><p>システム起動の早い段階で印刷する機能を持つearly_printk()を使用します。 ただし、一部のハードウェアシステムにしか対応していない。</p><p>#####3 LOGレベル<br> printkとprintfの大きな違いは、前者がLOGレベルを指定できることです。 カーネルは、このレベルを使用して、端末にメッセージを印刷するかどうかを決定します。 カーネルは、指定されたレベルより高いメッセージをすべてターミナルに表示します。<br>       LOGレベルは、以下のように指定することができる。<br>printk(KERN_CRIT “Hello, world!\n”);<br>最初のパラメータは、レベル (KERN_CRIT) をフォーマット文字から分離するためのカンマ (,) が入っていないので、本当のパラメータではないことに注意。 kern_crit 自体は単なる普通の文字列である ( 実際には、文字列 “&lt;2&gt;” を表す。ログレベルの全リストは、表 1 に示されている )。 C言語では、プリプロセッサの一部として、文字列連結と呼ばれる関数を使って、この2つの文字列を自動的に結合する。 この組み合わせにより、ログレベルとユーザが指定したフォーマット文字列が一つの文字列として含まれることになる。</p><p>カーネルは、この指定されたLOGレベルと現在の端末LOGレベル console_loglevel を用いて、端末に印刷するかどうかを決定する。<br>LOGレベルは以下の通りです。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define KERN_EMERG      &quot;&lt;0&gt;&quot;   /* system is unusable                            */</span><br><span class="line"></span><br><span class="line">#define KERN_ALERT        &quot;&lt;1&gt;&quot;   /* action must be taken immediately     */ </span><br><span class="line"></span><br><span class="line">#define KERN_CRIT           &quot;&lt;2&gt;&quot;   /* critical conditions                                */</span><br><span class="line"></span><br><span class="line">#define KERN_ERR            &quot;&lt;3&gt;&quot;   /* error conditions                                   */</span><br><span class="line"></span><br><span class="line">#define KERN_WARNING  &quot;&lt;4&gt;&quot;   /* warning conditions                              */</span><br><span class="line"></span><br><span class="line">#define KERN_NOTICE       &quot;&lt;5&gt;&quot;   /* normal but significant condition         */</span><br><span class="line"></span><br><span class="line">#define KERN_INFO            &quot;&lt;6&gt;&quot;   /* informational                                       */</span><br><span class="line"></span><br><span class="line">#define KERN_DEBUG        &quot;&lt;7&gt;&quot;   /* debug-level messages                       */</span><br><span class="line"></span><br><span class="line">#define KERN_DEFAULT     &quot;&lt;d&gt;&quot;   /* Use the default kernel loglevel           */</span><br></pre></td></tr></table></figure><p>呼び出し元が printk にログレベルを提供しない場合、デフォルト値 KERN_WARNING “&lt;4&gt;” が使用されることに注意してください (KERN_WARNING レベル以上のログメッセージのみがログ収集されることを示します)。 デフォルト値にはばらつきがあるため、使用する際はLOGレベルを指定した方が良い。 例えば、通常は KERN_WARNING レベル以上の重要な LOG を出力する必要がありますが、デバッグ時には KERN_DEBUG レベル以上の詳細な LOG を出力するように選択することができます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mtj@ubuntu :~$ cat /proc/sys/kernel/printk</span><br><span class="line"></span><br><span class="line">4 4 1 7</span><br><span class="line"></span><br><span class="line">mtj@ubuntu :~$ cat /proc/sys/kernel/printk_delay</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">mtj@ubuntu :~$ cat /proc/sys/kernel/printk_ratelimit</span><br><span class="line"></span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">mtj@ubuntu :~$ cat /proc/sys/kernel/printk_ratelimit_burst</span><br><span class="line"></span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>最初の項目は、printk API で現在使用されているロギングレベルを定義します。 これらのロギングレベルは、コンソールロギングレベル、デフォルトメッセージロギングレベル、最小コンソールロギングレベル、デフォルトコンソールロギングレベルを表す。 printk_delay 値は、printkメッセージ間の遅延ミリ秒数（いくつかのシナリオで読みやすくするために使用される）を表わす。 printk_ratelimit は、メッセージ間の許容最小時間間隔を定義します (現在、5 秒間に一定数のカーネルメッセージを送信すると定義されています)。 メッセージ数は printk_ratelimit_burst で定義される（現在 10 と定義されている）。 これは、非公式カーネルを使用していて、帯域幅に制限のあるコンソールデバイス（シリアルポート経由など）を使用している場合に有効です。 カーネルでは、速度制限は呼び出し側で制御され、printkには実装されていないことに注意してください。 printk ユーザーが速度制限を要求する場合、そのユーザーは printk_ratelimit 関数を呼び出す必要があります。</p><p>#####4 レコードバッファ</p><p>  カーネルメッセージは、LOG_BUF_LENサイズのリングキューに格納される。<br>  LOG_BUF_LENの定義について。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define __LOG_BUF_LEN (1 &lt;&lt; CONFIG_LOG_BUF_SHIFT)</span><br></pre></td></tr></table></figure><ul><li>CONFIG_LOG_BUF_SHIFT はカーネルコンパイル時に設定ファイルによって定義され、 i386 プラットフォームではその値は以下のように定義されています (linux26&#x2F;arch&#x2F;i386&#x2F;defconfig 内)。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_LOG_BUF_SHIFT=18</span><br></pre></td></tr></table></figure> バッファの操作を記録する。<br>  ユーザースペースにメッセージが読み出されると、このメッセージはリングキューから削除されます。<br>  メッセージ・バッファが一杯になったとき、別のprintk()呼び出しがあると、新しいメッセージはキュー内の古いメッセージを上書きします。<br>  リングキューへの読み書きを行う場合、同期の問題は簡単に解決されます。</li></ul><p>  このレコードバッファは、読み出し、書き込みともにリングキューで運用されるため、リングと呼ばれています。</p><p>#####5  syslogd&#x2F;klogd<br>標準的なLinuxシステムでは、ユーザースペースデーモンであるklogdは、 レコードバッファからカーネルメッセージを取得し、syslogdデーモン経由でシステム ログファイルに保存します。klogdプロセスは、&#x2F;proc&#x2F;kmsgファイルまたはsyslog() システムコールからメッセージを読み込むことが可能です。 デフォルトでは、&#x2F;procの実装方法を選択します。klogdデーモンは、メッセージバッファに新しいメッセージが利用可能になるまでブロックしたままになります。 新しいカーネルメッセージが利用可能になると、klogdは起動され、カーネルメッセージを読み込んで処理します。 デフォルトでは、処理ルーチンはカーネルメッセージをsyslogdデーモンに渡し、syslogdは通常、受信したメッセージを&#x2F;var&#x2F;log&#x2F;messagesファイルに書き込みます。 ただし、&#x2F;etc&#x2F;syslog.conf ファイルによる設定は可能であり、他の出力ファイルを選択することもできます。</p><p><img src="/../../../img/linux_kernel_debug/syslogd_klogd.jpg" alt="avatar"></p><p>#####6  dmesg</p><p>dmesgコマンドは、カーネルリングバッファーの表示と制御にも使用できます。 このコマンドは、klogctlシステムコールを使用して、カーネルリングバッファーを読み、標準出力（stdout）に転送します。 このコマンドは、カーネルリングバッファーのクリア（-c オプション）、コンソールログレベルの設定（-n オプション）、カーネルログメッセージを読むためのバッファーのサイズの定義（-s オプション）にも使用することができます。 バッファサイズが指定されていない場合、dmesg は klogctl の SYSLOG_ACTION_SIZE_BUFFER 操作を使用して、バッファサイズを決定することに注意してください。</p><p>#####7 注意<br>a) printkは非常に堅牢ですが、ソースコードを読めば、この関数が非常に非効率的であることがわかります。 そのため、ドライバがパフォーマンステストやデバッグ後のリリースを行う場合は、printk出力を最小限に抑え、エラーが発生した場合にのみ少量の情報を出力することを忘れないようにしてください。 さもないと、無駄な情報をコンソールに出力することになり、パフォーマンスに影響が出ます。<br>b) printk の一時キャッシュ printk_buf は 1K しかなく、すべての printk 関数はログバッファに &lt;1K の情報しか記録できず、printk は “ringbuffer” を使用します。</p><p>#####8 カーネルプリントクとロギングシステムの一般的な構造<br><img src="/../../../img/linux_kernel_debug/syslogd_klogd.jpg" alt="avatar"></p><p>#####9 ダイナミックコミッショニング<br>ダイナミックデバッグは、特定のカーネルコードを動的に有効&#x2F;無効にすることで、カーネルの追加情報を取得するために使用されます。<br>まず、カーネルオプションCONFIG_DYNAMIC_DEBUGを設定する必要があります。 pr_debug()&#x2F;dev_debug()で出力されるすべての情報は、動的に表示するかしないかを選択できます。<br>表示する情報は、簡単なクエリ文によってフィルタリングすることができます。</p><p>-ソースファイル名</p><p>-関数名</p><p>-行番号(指定範囲の行番号を含む)</p><p>-モジュール名</p><p>-書式設定文字列</p><p><debugfs>&#x2F;dynamic_debug&#x2F;control に出力する情報のフォーマットを記述する。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nullarbor:~ # echo &#x27;file svcsock.c line 1603 +p&#x27; &gt;      &lt;debugfs&gt;/dynamic_debug/control</span><br></pre></td></tr></table></figure><p>####VI メモリデバッギングツール<br>#####1  MEMWATCH<br>MEMWATCHはJohan Lindhによって書かれた、オープンソースのC言語メモリエラー検出ツールで、自分でダウンロードすることができます。 コードにヘッダーファイルを追加し、gcc文でMEMWATCHを定義すると、プログラム中のメモリリークやエラーを追跡することができます。 unfreedmemory）、オーバーフロー、アンダーフローなど。</p><p>リスト1.メモリーサンプル（test1.c）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;memwatch.h&quot;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"> char *ptr1;</span><br><span class="line"> char *ptr2;</span><br><span class="line"> ptr1 = malloc(512);</span><br><span class="line"> ptr2 = malloc(512);</span><br><span class="line"> ptr2 = ptr1;</span><br><span class="line"> free(ptr2);</span><br><span class="line"> free(ptr1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>リスト1のコードでは、2つの512バイトのメモリブロックを割り当て、最初のブロックへのポインタが2番目のメモリブロックを指すように設定されます。 その結果、2番目のブロックのアドレスが失われ、メモリリークが発生します。<br>リスト1のmemwatch.cをコンパイルします。以下はmakefileの例です。<br>test1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -DMEMWATCH -DMW_STDIO test1.c memwatch</span><br><span class="line">c -o test1</span><br></pre></td></tr></table></figure><p>当您运行 test1 程序后，它会生成一个关于泄漏的内存的报告。清单 2 展示了示例 memwatch.log 输出文件。 </p><p>清单 2. test1 memwatch.log 文件</p><pre><code>MEMWATCH 2.67 Copyright (C) 1992-1999 Johan Lindh...double-free: &lt;4&gt; test1.c(15), 0x80517b4 was freed from test1.c(14)...unfreed: &lt;2&gt; test1.c(11), 512 bytes at 0x80519e4&#123;FE FE FE FE FE FE FE FE FE FE FE FE ..............&#125;Memory usage statistics (global): N)umber of allocations made: 2 L)argest memory usage : 1024 T)otal of all alloc() calls: 1024 U)nfreed bytes totals : 512</code></pre><p> MEMWATCHは、実際に問題を起こしている行を表示します。 すでに解放されているポインタを解放すると、それを教えてくれます。 解放されていないメモリも同様です。 ログの最後には、どれだけメモリが漏れたか、どれだけメモリが使われたか、合計でどれだけメモリが割り当てられたかなどの統計が表示されます。</p><h5 id="2-YAMD"><a href="#2-YAMD" class="headerlink" title="2  YAMD"></a>2  YAMD</h5><p>YAMD パッケージは、C および C++における動的なメモリ割り当て関連の問題を発見するために Nate Eldredge によって書かれたものである。 yamd-0.32.tar.gz をダウンロードし、make コマンドを実行してプログラムをビルドし、 make install コマンドを実行してプログラムをインストールし、ツールをセットアップする。<br>YAMDをダウンロードしたら、test1.cで使用します。 #include memwatch.h を削除し、makefile に以下のような細かい変更を加えます。</p><p>YAMDを使ったテスト1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -DMEMWATCH -DMW_STDIO test1.c memwatch</span><br><span class="line">c -o test1</span><br></pre></td></tr></table></figure><h5 id="2-YAMD-1"><a href="#2-YAMD-1" class="headerlink" title="2  YAMD"></a>2  YAMD</h5><p>リスト 3 は test1 の YAMD からの出力です。</p><p>リスト3.YAMDを使ったtest1の出力</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">YAMD version 0.32</span><br><span class="line"></span><br><span class="line">Executable: /usr/src/test/yamd-0.32/test1</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">INFO: Normal allocation of this block</span><br><span class="line"></span><br><span class="line">Address 0x40025e00, size 512</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">INFO: Normal allocation of this block</span><br><span class="line"></span><br><span class="line">Address 0x40028e00, size 512</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">INFO: Normal deallocation of this block</span><br><span class="line"></span><br><span class="line">Address 0x40025e00, size 512</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ERROR: Multiple freeing At</span><br><span class="line"></span><br><span class="line">free of pointer already freed</span><br><span class="line"></span><br><span class="line">Address 0x40025e00, size 512</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">WARNING: Memory leak</span><br><span class="line"></span><br><span class="line">Address 0x40028e00, size 512</span><br><span class="line"></span><br><span class="line">WARNING: Total memory leaks:</span><br><span class="line"></span><br><span class="line">1 unfreed allocations totaling 512 bytes</span><br><span class="line"></span><br><span class="line">*** Finished at Tue ... 10:07:15 2002</span><br><span class="line"></span><br><span class="line">Allocated a grand total of 1024 bytes 2 allocations</span><br><span class="line"></span><br><span class="line">Average of 512 bytes per allocation</span><br><span class="line"></span><br><span class="line">Max bytes allocated at one time: 1024</span><br><span class="line"></span><br><span class="line">24 K alloced internally / 12 K mapped now / 8 K max</span><br><span class="line"></span><br><span class="line">Virtual program size is 1416 K</span><br><span class="line"></span><br><span class="line">End.</span><br></pre></td></tr></table></figure><p>MEMWATCHとYAMDはどちらも便利なデバッグツールですが、その使い方は様々です。 MEMWATCHの場合、インクルードファイルmemwatch.hを追加し、2つのコンパイル時タグをオンにする必要があります。 リンク文の場合、YAMD は -g オプションのみを必要とします。</p><p>#####3  Electric Fence<br>electric Fence は Bruce Perens 氏によって書かれた malloc() デバッギングライブラリで、ほとんどの Linux ディストリビューションには Electric Fence パッケージが含まれていますが、ダウンロードすることも可能です。 保護されたメモリを割り当てた直後に、そのメモリが割り当てられるのです。 フェンスポストエラー（配列の終端を超えて実行）が発生した場合、プログラムはプロテクトエラーを発生し、直ちに終了します。 Electric Fenceとgdbを組み合わせることで、どの行が保護されたメモリにアクセスしようとしているかを正確に追跡することができる。ElectricFenceのもう一つの特徴は、メモリリークを検出する機能である。</p><p>####VIIストレース<br>strace コマンドは、ユーザースペースプログラムが発行するすべてのシステムコールを表示する強力なツールです。strace はこれらのコールに対する引数を表示し、シンボル形式で値を返します。strace はカーネルから情報を受け取り、特別な方法でカーネルを構築する必要はありません。 アプリケーションやカーネル開発者にもトレース情報を送ることができ、便利です。 リスト 6 では、パーティション形式の 1 つにエラーがあり、リストには、ファイルシステムの作成操作 (mkfs) を呼び出すことに関する strace の始まりが示されています。strace は、どの呼び出しが問題を引き起こしているかを判断しています。<br>リストアップ<br>6. mkfs の strace の開始。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;/sbin/mkfs.jfs&quot;, [&quot;mkfs.jfs&quot;, &quot;-f&quot;, &quot;/dev/test1&quot;], &amp;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">open(&quot;/dev/test1&quot;, O_RDWR|O_LARGEFILE) = 4</span><br><span class="line"></span><br><span class="line">stat64(&quot;/dev/test1&quot;, &#123;st_mode=&amp;, st_rdev=makedev(63, 255), ...&#125;) = 0</span><br><span class="line"></span><br><span class="line">ioctl(4, 0x40041271, 0xbfffe128) = -1 EINVAL (Invalid argument)</span><br><span class="line"></span><br><span class="line">write(2, &quot;mkfs.jfs: warning - cannot setb&quot; ..., 98mkfs.jfs: warning -</span><br><span class="line"></span><br><span class="line">cannot set blocksize on block device /dev/test1: Invalid argument )</span><br><span class="line"></span><br><span class="line"> = 98</span><br><span class="line"></span><br><span class="line">stat64(&quot;/dev/test1&quot;, &#123;st_mode=&amp;, st_rdev=makedev(63, 255), ...&#125;) = 0</span><br><span class="line"></span><br><span class="line">open(&quot;/dev/test1&quot;, O_RDONLY|O_LARGEFILE) = 5</span><br><span class="line"></span><br><span class="line">ioctl(5, 0x80041272, 0xbfffe124) = -1 EINVAL (Invalid argument)</span><br><span class="line"></span><br><span class="line">write(2, &quot;mkfs.jfs: can\&#x27;t determine device&quot;..., ..._exit(1)</span><br><span class="line"></span><br><span class="line"> = ?</span><br></pre></td></tr></table></figure><p>リスト6では、ioctlの呼び出しによって、パーティションをフォーマットするために使用されるmkfsプログラムが失敗することが示されています。ioctl BLKGETSIZE64 に失敗しました。 (BLKGET-SIZE64はioctlを呼び出すソースコードで定義されています)。BLKGETSIZE64 ioctl は、論理ボリューム・マネージャーでまだサポートされていない Linux のすべてのデバイスに追加されます。 そのため、BLKGETSIZE64 ioctlコールが失敗した場合、mkfsコードは代わりに以前のioctlコールを呼び出すことになります。</p><p>####VIII OOPS</p>]]></content>
      
      
      <categories>
          
          <category> linux kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux kernel </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
